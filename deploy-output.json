{"name":"whatsapp-webhook","slug":"whatsapp-webhook","verify_jwt":false,"entrypoint_path":"index.ts","files":[{"name":"index.ts","content":"import { createClient } from 'npm:@supabase/supabase-js@2.86.2';\nimport { ethers } from 'npm:ethers@6.16.0';\nimport CryptoJS from 'npm:crypto-js@4.2.0';\nimport 'jsr:@supabase/functions-js/edge-runtime.d.ts';\nimport {\n  createChamaOnChain,\n  joinChamaOnChain,\n  contributeToChamaOnChain,\n  requestLoanOnChain,\n  voteOnLoanOnChain,\n  getExplorerLink,\n  getAddressExplorerLink,\n} from './blockchain.ts';\n\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Client-Info, Apikey',\n};\n\n// Environment variables\nconst META_WEBHOOK_VERIFY_TOKEN = Deno.env.get('META_WEBHOOK_VERIFY_TOKEN');\nconst META_ACCESS_TOKEN = Deno.env.get('META_ACCESS_TOKEN');\nconst META_PHONE_NUMBER_ID = Deno.env.get('META_PHONE_NUMBER_ID');\nconst ENCRYPTION_KEY = Deno.env.get('ENCRYPTION_KEY');\nconst ALCHEMY_API_KEY = Deno.env.get('ALCHEMY_API_KEY');\nconst ZENO_API_KEY = Deno.env.get('ZENO_API_KEY');\nconst SUPABASE_URL = Deno.env.get('SUPABASE_URL');\nconst SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');\nconst FX_RATES_API_KEY = Deno.env.get('FX_RATES_API_KEY') || 'demo';\n\n// Constants\nconst APP_NAME = 'üå≥üáπüáø INUKA Pay';\nconst APP_DESCRIPTION = 'Your gateway to financial freedom through crypto savings and group lending';\nconst SESSION_TIMEOUT_MS = 15 * 60 * 1000;\nconst WEBHOOK_URL = `${SUPABASE_URL}/functions/v1/zeno-webhook`;\nconst ZENO_API_URL = 'https://zenoapi.com/api/payments';\nconst FX_RATES_API_URL = 'https://api.exchangerate-api.io/v4/latest/USD';\n\n// RPC Configuration\nconst SCROLL_SEPOLIA_RPC_URL = ALCHEMY_API_KEY\n  ? `https://scroll-sepolia.g.alchemy.com/v2/${ALCHEMY_API_KEY}`\n  : 'https://sepolia-rpc.scroll.io';\n\nconst SCROLL_SEPOLIA_CHAIN_ID = 534351;\nconst SCROLL_SEPOLIA_EXPLORER = 'https://sepolia.scrollscan.com';\nconst NETWORK = 'scroll-sepolia';\n\n// Token configurations - TZS replaces USDT\nconst TOKENS = {\n  ETH: {\n    name: 'Ethereum',\n    symbol: 'ETH',\n    decimals: 18,\n    contractAddress: null,\n  },\n  TZS: {\n    name: 'Tanzanian Shilling',\n    symbol: 'TZS',\n    decimals: 6,\n    contractAddress: '0x9e47f86a074463f7f51063761f4692AC04770a40',\n    abi: [\n      'function balanceOf(address owner) view returns (uint256)',\n      'function transfer(address to, uint256 amount) returns (bool)',\n      'function allowance(address owner, address spender) view returns (uint256)',\n      'function approve(address spender, uint256 amount) returns (bool)'\n    ]\n  }\n};\n\nconst supabase = createClient(SUPABASE_URL!, SUPABASE_SERVICE_ROLE_KEY!);\nconst META_API_URL = `https://graph.facebook.com/v21.0/${META_PHONE_NUMBER_ID}/messages`;\n\n// ============================================================================\n// EXCHANGE RATE MANAGEMENT\n// ============================================================================\ninterface FXRates {\n  ETH_USD: number;\n  USD_TZS: number;\n  ETH_TZS: number;\n  lastUpdated: number;\n}\n\nlet cachedFXRates: FXRates | null = null;\nconst FX_CACHE_TTL = 5 * 60 * 1000;\n\nasync function fetchRealTimeFXRates(): Promise<FXRates> {\n  const now = Date.now();\n  if (cachedFXRates && (now - cachedFXRates.lastUpdated) < FX_CACHE_TTL) {\n    return cachedFXRates;\n  }\n\n  try {\n    const fxResponse = await fetch(`${FX_RATES_API_URL}?apikey=${FX_RATES_API_KEY}`);\n    const fxData = await fxResponse.json();\n    const usdToTzs = fxData.rates?.TZS || 2500;\n\n    const ethResponse = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');\n    const ethData = await ethResponse.json();\n    const ethToUsd = ethData.ethereum?.usd || 2000;\n    const ethToTzs = ethToUsd * usdToTzs;\n\n    cachedFXRates = {\n      ETH_USD: ethToUsd,\n      USD_TZS: usdToTzs,\n      ETH_TZS: ethToTzs,\n      lastUpdated: now\n    };\n\n    await supabase.from('fx_rates').upsert([\n      { currency_pair: 'ETH_USD', rate: ethToUsd, last_updated: new Date().toISOString() },\n      { currency_pair: 'USD_TZS', rate: usdToTzs, last_updated: new Date().toISOString() },\n      { currency_pair: 'ETH_TZS', rate: ethToTzs, last_updated: new Date().toISOString() }\n    ], { onConflict: 'currency_pair' });\n\n    return cachedFXRates;\n  } catch (error) {\n    console.error('Error fetching FX rates:', error);\n    const { data } = await supabase.from('fx_rates').select('*');\n    if (data && data.length > 0) {\n      const rates: any = {};\n      data.forEach(row => { rates[row.currency_pair] = row.rate; });\n      cachedFXRates = {\n        ETH_USD: rates.ETH_USD || 2000,\n        USD_TZS: rates.USD_TZS || 2500,\n        ETH_TZS: rates.ETH_TZS || 5000000,\n        lastUpdated: now\n      };\n      return cachedFXRates;\n    }\n    return { ETH_USD: 2000, USD_TZS: 2500, ETH_TZS: 5000000, lastUpdated: now };\n  }\n}\n\nasync function convertCurrency(amount: number, from: string, to: string): Promise<number> {\n  if (from === to) return amount;\n  const rates = await fetchRealTimeFXRates();\n  let result = amount;\n\n  if (from === 'ETH' && to === 'TZS') result = amount * rates.ETH_TZS;\n  else if (from === 'TZS' && to === 'ETH') result = amount / rates.ETH_TZS;\n  else if (from === 'ETH' && to === 'USD') result = amount * rates.ETH_USD;\n  else if (from === 'USD' && to === 'ETH') result = amount / rates.ETH_USD;\n  else if (from === 'USD' && to === 'TZS') result = amount * rates.USD_TZS;\n  else if (from === 'TZS' && to === 'USD') result = amount / rates.USD_TZS;\n\n  return parseFloat(result.toFixed(6));\n}\n\n// ============================================================================\n// PROVIDER & WALLET MANAGEMENT\n// ============================================================================\nlet providerInstance: ethers.JsonRpcProvider | null = null;\n\nfunction getProvider() {\n  if (providerInstance) return providerInstance;\n  const network = new ethers.Network('scroll-sepolia', SCROLL_SEPOLIA_CHAIN_ID);\n  providerInstance = new ethers.JsonRpcProvider(SCROLL_SEPOLIA_RPC_URL, network, {\n    staticNetwork: network\n  });\n  return providerInstance;\n}\n\nconst balanceCache = new Map<string, { eth: string; tzs: string; timestamp: number }>();\nconst CACHE_TTL = 30000;\n\nsetInterval(() => {\n  const now = Date.now();\n  for (const [address, data] of balanceCache.entries()) {\n    if (now - data.timestamp > CACHE_TTL) {\n      balanceCache.delete(address);\n    }\n  }\n}, 60000);\n\n// ============================================================================\n// ENCRYPTION & SECURITY UTILITIES\n// ============================================================================\nfunction encrypt(text: string): string {\n  return CryptoJS.AES.encrypt(text, ENCRYPTION_KEY!).toString();\n}\n\nfunction decrypt(encryptedText: string): string {\n  const bytes = CryptoJS.AES.decrypt(encryptedText, ENCRYPTION_KEY!);\n  return bytes.toString(CryptoJS.enc.Utf8);\n}\n\nfunction hashPin(pin: string): string {\n  return CryptoJS.SHA256(pin + ENCRYPTION_KEY).toString();\n}\n\nfunction isValidPinFormat(pin: string): boolean {\n  return /^\\d{4,6}$/.test(pin.toString().trim());\n}\n\nfunction formatBalance(balance: string | number): string {\n  const num = parseFloat(balance.toString());\n  if (num === 0) return '0';\n  if (num < 0.0001) return num.toExponential(4);\n  return num.toFixed(6).replace(/\\.?0+$/, '');\n}\n\nfunction formatTZS(amount: number): string {\n  return Math.round(amount).toLocaleString('en-US');\n}\n\nfunction formatUSD(amount: number): string {\n  return amount.toFixed(2);\n}\n\nfunction isValidAddress(address: string): boolean {\n  return ethers.isAddress(address);\n}\n\nfunction generateOrderId(userId: string): string {\n  const timestamp = Date.now();\n  const random = Math.floor(Math.random() * 10000);\n  return `MM-${userId.substring(0, 8)}-${timestamp}-${random}`;\n}\n\n// ============================================================================\n// WALLET OPERATIONS\n// ============================================================================\nfunction createWallet() {\n  const wallet = ethers.Wallet.createRandom();\n  return {\n    address: wallet.address,\n    privateKey: wallet.privateKey,\n    mnemonic: wallet.mnemonic!.phrase,\n  };\n}\n\nfunction getWalletFromEncrypted(encryptedPrivateKey: string) {\n  const privateKey = decrypt(encryptedPrivateKey);\n  return new ethers.Wallet(privateKey, getProvider());\n}\n\nasync function getTokenBalance(address: string, tokenSymbol: string): Promise<string> {\n  const provider = getProvider();\n  if (tokenSymbol === 'ETH') {\n    const balance = await provider.getBalance(address);\n    return ethers.formatEther(balance);\n  } else if (tokenSymbol === 'TZS') {\n    const token = TOKENS.TZS;\n    const contract = new ethers.Contract(token.contractAddress!, token.abi!, provider);\n    const balance = await contract.balanceOf(address);\n    return ethers.formatUnits(balance, token.decimals);\n  }\n  return '0';\n}\n\nasync function getAllBalances(address: string): Promise<{ eth: string; tzs: string }> {\n  const cached = balanceCache.get(address);\n  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n    return { eth: cached.eth, tzs: cached.tzs };\n  }\n\n  const [ethBalance, tzsBalance] = await Promise.all([\n    getTokenBalance(address, 'ETH'),\n    getTokenBalance(address, 'TZS')\n  ]);\n\n  balanceCache.set(address, {\n    eth: ethBalance,\n    tzs: tzsBalance,\n    timestamp: Date.now()\n  });\n\n  return { eth: ethBalance, tzs: tzsBalance };\n}\n\nasync function sendToken(encryptedPrivateKey: string, toAddress: string, amount: string, tokenSymbol: string) {\n  const wallet = getWalletFromEncrypted(encryptedPrivateKey);\n  if (tokenSymbol === 'ETH') {\n    const tx = await wallet.sendTransaction({\n      to: toAddress,\n      value: ethers.parseEther(amount),\n    });\n    return tx;\n  } else if (tokenSymbol === 'TZS') {\n    const token = TOKENS.TZS;\n    const contract = new ethers.Contract(token.contractAddress!, token.abi!, wallet);\n    const amountInUnits = ethers.parseUnits(amount, token.decimals);\n    const tx = await contract.transfer(toAddress, amountInUnits);\n    return tx;\n  }\n  throw new Error(`Unsupported token: ${tokenSymbol}`);\n}\n\n// ============================================================================\n// ZENO PAYMENT INTEGRATION\n// ============================================================================\nfunction formatPhoneNumber(phone: string): string {\n  if (phone.startsWith('255')) {\n    return '0' + phone.substring(3);\n  }\n  return phone;\n}\n\nfunction generateBuyerInfo(phone: string): { email: string; name: string } {\n  const formattedPhone = formatPhoneNumber(phone);\n  return {\n    email: `${formattedPhone}@inuka.pay`,\n    name: `User ${formattedPhone}`\n  };\n}\n\nasync function createDepositOrder(orderId: string, phoneNumber: string, tzsAmount: number) {\n  try {\n    const formattedPhone = formatPhoneNumber(phoneNumber);\n    const buyerInfo = generateBuyerInfo(phoneNumber);\n\n    const response = await fetch(`${ZENO_API_URL}/mobile_money_tanzania`, {\n      method: 'POST',\n      headers: {\n        'x-api-key': ZENO_API_KEY!,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        order_id: orderId,\n        buyer_email: buyerInfo.email,\n        buyer_name: buyerInfo.name,\n        buyer_phone: formattedPhone,\n        amount: tzsAmount,\n        webhook_url: WEBHOOK_URL,\n      }),\n    });\n\n    const result = await response.json();\n    if (!response.ok || result.status !== 'success') {\n      return {\n        success: false,\n        error: result.message || 'Failed to create deposit order',\n      };\n    }\n    return { success: true, data: result };\n  } catch (error) {\n    console.error('Zeno deposit error:', error);\n    return { success: false, error: 'Failed to create deposit order' };\n  }\n}\n\nasync function createWithdrawalOrder(orderId: string, phoneNumber: string, tzsAmount: number) {\n  try {\n    const formattedPhone = formatPhoneNumber(phoneNumber);\n    const buyerInfo = generateBuyerInfo(phoneNumber);\n\n    const response = await fetch(`${ZENO_API_URL}/mobile_money_tanzania`, {\n      method: 'POST',\n      headers: {\n        'x-api-key': ZENO_API_KEY!,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        order_id: orderId,\n        buyer_email: buyerInfo.email,\n        buyer_name: buyerInfo.name,\n        buyer_phone: formattedPhone,\n        amount: tzsAmount,\n        webhook_url: WEBHOOK_URL,\n      }),\n    });\n\n    const result = await response.json();\n    if (!response.ok || result.status !== 'success') {\n      return {\n        success: false,\n        error: result.message || 'Failed to create withdrawal order',\n      };\n    }\n    return { success: true, data: result };\n  } catch (error) {\n    console.error('Zeno withdrawal error:', error);\n    return { success: false, error: 'Failed to create withdrawal order' };\n  }\n}\n\n// ============================================================================\n// WHATSAPP MESSAGING\n// ============================================================================\nfunction addHomeButton(buttons: any[]): any[] {\n  if (buttons.length < 3) {\n    return [...buttons, { id: 'menu', title: 'üè† Home' }];\n  }\n  return buttons;\n}\n\nasync function sendWhatsAppMessage(to: string, message: string) {\n  if (!META_ACCESS_TOKEN || !META_PHONE_NUMBER_ID) return null;\n  const enhancedMessage = message + '\\n\\n_Type *menu* to return home_';\n\n  try {\n    const response = await fetch(META_API_URL, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${META_ACCESS_TOKEN}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        messaging_product: 'whatsapp',\n        recipient_type: 'individual',\n        to: to,\n        type: 'text',\n        text: {\n          preview_url: false,\n          body: enhancedMessage,\n        },\n      }),\n    });\n    return await response.json();\n  } catch (error) {\n    console.error('Error sending WhatsApp message:', error);\n    throw error;\n  }\n}\n\nasync function sendButtonMessage(to: string, bodyText: string, buttons: any[], footerText?: string) {\n  if (!META_ACCESS_TOKEN || !META_PHONE_NUMBER_ID) return null;\n  const buttonsWithHome = addHomeButton(buttons);\n\n  try {\n    const interactive: any = {\n      type: 'button',\n      body: { text: bodyText },\n      action: {\n        buttons: buttonsWithHome.slice(0, 3).map((btn: any, idx: number) => ({\n          type: 'reply',\n          reply: {\n            id: btn.id || `btn_${idx}`,\n            title: btn.title.substring(0, 20),\n          },\n        })),\n      },\n    };\n\n    if (footerText) {\n      interactive.footer = { text: footerText };\n    }\n\n    const response = await fetch(META_API_URL, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${META_ACCESS_TOKEN}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        messaging_product: 'whatsapp',\n        recipient_type: 'individual',\n        to: to,\n        type: 'interactive',\n        interactive,\n      }),\n    });\n    return await response.json();\n  } catch (error) {\n    console.error('Error sending button message:', error);\n    throw error;\n  }\n}\n\nasync function sendListMessage(to: string, bodyText: string, buttonText: string, sections: any[]) {\n  if (!META_ACCESS_TOKEN || !META_PHONE_NUMBER_ID) return null;\n\n  try {\n    const response = await fetch(META_API_URL, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${META_ACCESS_TOKEN}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        messaging_product: 'whatsapp',\n        recipient_type: 'individual',\n        to: to,\n        type: 'interactive',\n        interactive: {\n          type: 'list',\n          body: { text: bodyText },\n          action: {\n            button: buttonText,\n            sections: sections,\n          },\n        },\n      }),\n    });\n    return await response.json();\n  } catch (error) {\n    console.error('Error sending list message:', error);\n    throw error;\n  }\n}\n\n// ============================================================================\n// NOTIFICATION SYSTEM\n// ============================================================================\nasync function createNotification(userId: string, type: string, title: string, message: string, data: any = {}) {\n  await supabase.from('notifications').insert([{\n    user_id: userId,\n    notification_type: type,\n    title,\n    message,\n    data\n  }]);\n}\n\nasync function notifyTransaction(recipientId: string, amount: string, token: string, fromUser: any) {\n  const user = await supabase.from('users').select('whatsapp_number').eq('id', recipientId).maybeSingle();\n\n  if (user.data) {\n    const tzsValue = token === 'ETH'\n      ? await convertCurrency(parseFloat(amount), 'ETH', 'TZS')\n      : parseFloat(amount);\n    const usdValue = await convertCurrency(tzsValue, 'TZS', 'USD');\n\n    const message = `üí∞ *Payment Received!*\n\nYou received ${formatBalance(amount)} ${token}\n‚âà ${formatTZS(tzsValue)} TZS\n‚âà $${formatUSD(usdValue)} USD\n\nFrom: ${fromUser?.whatsapp_number || 'External'}\nTime: ${new Date().toLocaleString('en-US', { timeZone: 'Africa/Dar_es_Salaam' })}`;\n\n    await sendButtonMessage(\n      user.data.whatsapp_number,\n      message,\n      [\n        { id: 'balance', title: 'üí∞ View Balance' },\n        { id: 'send', title: 'üì§ Send' },\n        { id: 'menu', title: 'üè† Home' }\n      ]\n    );\n    await createNotification(recipientId, 'transaction_received', 'Payment Received', message, {\n      amount, token, from: fromUser?.id\n    });\n  }\n}\n\nasync function notifyChamaMembers(chamaId: string, title: string, message: string, excludeUserId?: string) {\n  const { data: members } = await supabase\n    .from('chama_members')\n    .select('user_id, users(whatsapp_number)')\n    .eq('chama_id', chamaId)\n    .eq('status', 'active');\n\n  if (members) {\n    for (const member of members) {\n      if (excludeUserId && member.user_id === excludeUserId) continue;\n      const user: any = member.users;\n      if (user?.whatsapp_number) {\n        await sendWhatsAppMessage(user.whatsapp_number, message);\n        await createNotification(member.user_id, 'chama_notification', title, message, { chamaId });\n      }\n    }\n  }\n}\n\n// ============================================================================\n// DATABASE OPERATIONS\n// ============================================================================\nasync function getUserByWhatsApp(whatsappNumber: string) {\n  const { data, error } = await supabase.from('users').select('*').eq('whatsapp_number', whatsappNumber).maybeSingle();\n  if (error) throw error;\n  return data;\n}\n\nasync function getUserByPhone(phone: string) {\n  let normalizedPhone = phone.trim().replace(/[^\\d+]/g, '');\n  const phoneFormats = [\n    normalizedPhone,\n    normalizedPhone.startsWith('0') ? '255' + normalizedPhone.substring(1) : normalizedPhone,\n    normalizedPhone.startsWith('255') ? normalizedPhone : '255' + normalizedPhone,\n    normalizedPhone.startsWith('+255') ? normalizedPhone.substring(1) : normalizedPhone,\n  ];\n\n  for (const format of phoneFormats) {\n    const user = await getUserByWhatsApp(format);\n    if (user) return user;\n  }\n  return null;\n}\n\nasync function createUser(userData: any) {\n  const { data, error } = await supabase.from('users').insert([userData]).select().single();\n  if (error) throw error;\n  return data;\n}\n\nasync function updateUser(userId: string, updates: any) {\n  const { data, error } = await supabase.from('users').update(updates).eq('id', userId).select().single();\n  if (error) throw error;\n  return data;\n}\n\nasync function getActiveSession(userId: string) {\n  const { data, error } = await supabase\n    .from('message_sessions')\n    .select('*')\n    .eq('user_id', userId)\n    .gt('expires_at', new Date().toISOString())\n    .order('created_at', { ascending: false })\n    .maybeSingle();\n  if (error) throw error;\n  return data;\n}\n\nasync function createSession(sessionData: any) {\n  const expiresAt = new Date(Date.now() + SESSION_TIMEOUT_MS);\n  const { data, error } = await supabase\n    .from('message_sessions')\n    .insert([{ ...sessionData, expires_at: expiresAt.toISOString() }])\n    .select()\n    .single();\n  if (error) throw error;\n  return data;\n}\n\nasync function updateSession(sessionId: string, updates: any) {\n  const expiresAt = new Date(Date.now() + SESSION_TIMEOUT_MS);\n  const { data, error } = await supabase\n    .from('message_sessions')\n    .update({ ...updates, expires_at: expiresAt.toISOString() })\n    .eq('id', sessionId)\n    .select()\n    .single();\n  if (error) throw error;\n  return data;\n}\n\nasync function deleteSession(sessionId: string) {\n  const { error } = await supabase.from('message_sessions').delete().eq('id', sessionId);\n  if (error) throw error;\n}\n\nasync function getUserPin(userId: string) {\n  const { data, error } = await supabase.from('user_pins').select('*').eq('user_id', userId).maybeSingle();\n  if (error) throw error;\n  return data;\n}\n\nasync function createUserPin(pinData: any) {\n  const { data, error } = await supabase.from('user_pins').insert([pinData]).select().single();\n  if (error) throw error;\n  return data;\n}\n\nasync function updateUserPin(userId: string, updates: any) {\n  const { data, error } = await supabase.from('user_pins').update(updates).eq('user_id', userId).select().single();\n  if (error) throw error;\n  return data;\n}\n\nasync function verifyPin(userId: string, pin: string) {\n  const pinData = await getUserPin(userId);\n  if (!pinData) return { success: false, error: 'PIN not set up' };\n\n  if (pinData.locked_until && new Date(pinData.locked_until) > new Date()) {\n    const remainingMinutes = Math.ceil((new Date(pinData.locked_until).getTime() - new Date().getTime()) / 60000);\n    return { success: false, error: `Account locked. Try again in ${remainingMinutes} minute(s)`, locked: true };\n  }\n\n  const hashedPin = hashPin(pin);\n  if (hashedPin === pinData.encrypted_pin) {\n    await updateUserPin(userId, { failed_attempts: 0, locked_until: null });\n    return { success: true };\n  } else {\n    const newFailedAttempts = pinData.failed_attempts + 1;\n    const updates: any = { failed_attempts: newFailedAttempts };\n    if (newFailedAttempts >= 3) {\n      updates.locked_until = new Date(Date.now() + 5 * 60 * 1000).toISOString();\n    }\n    await updateUserPin(userId, updates);\n    const remainingAttempts = 3 - newFailedAttempts;\n    if (remainingAttempts <= 0) {\n      return { success: false, error: 'Too many failed attempts. Account locked for 5 minutes', locked: true };\n    }\n    return { success: false, error: `Incorrect PIN. ${remainingAttempts} attempt(s) remaining`, remainingAttempts };\n  }\n}\n\nasync function createTransaction(txData: any) {\n  const { data, error } = await supabase.from('transactions').insert([txData]).select().single();\n  if (error) throw error;\n  return data;\n}\n\nasync function getTransactionsByUser(userId: string, limit = 10) {\n  const { data, error } = await supabase\n    .from('transactions')\n    .select('*')\n    .or(`from_user_id.eq.${userId},to_user_id.eq.${userId}`)\n    .order('created_at', { ascending: false })\n    .limit(limit);\n  if (error) throw error;\n  return data;\n}\n\nasync function createMobileMoneyTransaction(txData: any) {\n  const { data, error } = await supabase.from('mobile_money_transactions').insert([txData]).select().single();\n  if (error) throw error;\n  return data;\n}\n\nasync function getUserChamas(userId: string) {\n  const { data, error } = await supabase\n    .from('chama_members')\n    .select('*, chamas(*)')\n    .eq('user_id', userId)\n    .eq('status', 'active');\n  if (error) throw error;\n  return data;\n}\n\nasync function getChamaByInviteCode(inviteCode: string) {\n  const { data, error} = await supabase.from('chamas').select('*').eq('invite_code', inviteCode).maybeSingle();\n  if (error) throw error;\n  return data;\n}\n\nasync function getChamaById(chamaId: string) {\n  const { data, error } = await supabase.from('chamas').select('*').eq('id', chamaId).maybeSingle();\n  if (error) throw error;\n  return data;\n}\n\nasync function createChama(chamaData: any) {\n  const { data, error } = await supabase.from('chamas').insert([chamaData]).select().single();\n  if (error) throw error;\n  return data;\n}\n\nasync function createChamaMember(memberData: any) {\n  const { data, error } = await supabase.from('chama_members').insert([memberData]).select().single();\n  if (error) throw error;\n  return data;\n}\n\nasync function updateChama(chamaId: string, updates: any) {\n  const { data, error } = await supabase.from('chamas').update(updates).eq('id', chamaId).select().single();\n  if (error) throw error;\n  return data;\n}\n\nasync function updateChamaMember(memberId: string, updates: any) {\n  const { data, error } = await supabase.from('chama_members').update(updates).eq('id', memberId).select().single();\n  if (error) throw error;\n  return data;\n}\n\nasync function createChamaContribution(contributionData: any) {\n  const { data, error } = await supabase.from('chama_contributions').insert([contributionData]).select().single();\n  if (error) throw error;\n  return data;\n}\n\nasync function getChamaMemberByUserAndChama(userId: string, chamaId: string) {\n  const { data, error } = await supabase\n    .from('chama_members')\n    .select('*')\n    .eq('user_id', userId)\n    .eq('chama_id', chamaId)\n    .maybeSingle();\n  if (error) throw error;\n  return data;\n}\n\nasync function getChamaLoans(chamaId: string | null, borrowerId: string | null) {\n  let query = supabase\n    .from('chama_loans')\n    .select('*, users(whatsapp_number), chamas(name)')\n    .order('created_at', { ascending: false });\n  if (chamaId) query = query.eq('chama_id', chamaId);\n  if (borrowerId) query = query.eq('borrower_id', borrowerId);\n  const { data, error } = await query;\n  if (error) throw error;\n  return data;\n}\n\nasync function createLoan(loanData: any) {\n  const { data, error } = await supabase.from('chama_loans').insert([loanData]).select().single();\n  if (error) throw error;\n  return data;\n}\n\nasync function updateLoan(loanId: string, updates: any) {\n  const { data, error } = await supabase.from('chama_loans').update(updates).eq('id', loanId).select().single();\n  if (error) throw error;\n  return data;\n}\n\nasync function callDatabaseFunction(functionName: string, params: any) {\n  const { data, error } = await supabase.rpc(functionName, params);\n  if (error) throw error;\n  return data;\n}\n\n// ============================================================================\n// COMMAND HANDLERS\n// ============================================================================\nasync function handleNewUser(from: string) {\n  try {\n    const wallet = createWallet();\n    const userData = {\n      whatsapp_number: from,\n      wallet_address: wallet.address,\n      encrypted_private_key: encrypt(wallet.privateKey),\n      encrypted_mnemonic: encrypt(wallet.mnemonic),\n      is_onboarded: false,\n      pin_setup_completed: false,\n      eth_balance: 0,\n      tzs_balance: 0,\n    };\n    const user = await createUser(userData);\n\n    const welcomeMessage = `üéâ *Welcome to ${APP_NAME}!*\n${APP_DESCRIPTION}\n\nYour wallet has been created!\n\nüìç *Your Address:*\n\\`${wallet.address}\\`\n\n‚ö†Ô∏è *SAVE YOUR RECOVERY PHRASE:*\n\\`${wallet.mnemonic}\\`\n\n‚Ä¢ Write it down and store safely\n‚Ä¢ NEVER share with anyone\n‚Ä¢ You'll need it to recover your wallet`;\n\n    await sendWhatsAppMessage(from, welcomeMessage);\n\n    await createSession({\n      user_id: user.id,\n      session_type: 'setup_pin',\n      current_step: 'ask_pin',\n      session_data: {},\n    });\n\n    await sendWhatsAppMessage(from, 'üîê *Security Setup*\\n\\nCreate a 4-6 digit PIN:\\n\\nEnter your PIN:');\n  } catch (error) {\n    console.error('Error creating user:', error);\n    await sendWhatsAppMessage(from, '‚ùå Error creating wallet. Try again.');\n  }\n}\n\nasync function handleBalanceCommand(user: any) {\n  try {\n    const balances = await getAllBalances(user.wallet_address);\n    const rates = await fetchRealTimeFXRates();\n\n    const ethInTzs = await convertCurrency(parseFloat(balances.eth), 'ETH', 'TZS');\n    const ethInUsd = await convertCurrency(parseFloat(balances.eth), 'ETH', 'USD');\n    const tzsValue = parseFloat(balances.tzs);\n    const tzsInUsd = await convertCurrency(tzsValue, 'TZS', 'USD');\n    const totalTzs = ethInTzs + tzsValue;\n    const totalUsd = ethInUsd + tzsInUsd;\n\n    const message = `üí∞ *Your Balance*\n\n*ETH:* ${formatBalance(balances.eth)}\n  ‚âà ${formatTZS(ethInTzs)} TZS\n  ‚âà $${formatUSD(ethInUsd)} USD\n\n*TZS:* ${formatBalance(balances.tzs)}\n  ‚âà $${formatUSD(tzsInUsd)} USD\n\n*Total Value:*\n  ${formatTZS(totalTzs)} TZS\n  $${formatUSD(totalUsd)} USD\n\nüìç *Address:* \\`${user.wallet_address}\\`\nNetwork: Scroll Sepolia`;\n\n    await sendButtonMessage(\n      user.whatsapp_number,\n      message,\n      [\n        { id: 'send', title: 'üì§ Send' },\n        { id: 'deposit', title: 'üí≥ Deposit' },\n        { id: 'chama', title: 'üë• Save in Chama' }\n      ],\n      'What would you like to do?'\n    );\n  } catch (error) {\n    console.error('Error checking balance:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error checking balance.');\n  }\n}\n\nasync function showMainMenu(user: any) {\n  const message = `${APP_NAME}\n${APP_DESCRIPTION}\n\nWhat would you like to do?`;\n\n  await sendButtonMessage(\n    user.whatsapp_number,\n    message,\n    [\n      { id: 'wallet_menu', title: 'üí∞ Wallet' },\n      { id: 'money_savings', title: 'üí≥ Money & Savings' },\n      { id: 'settings_menu', title: '‚öôÔ∏è Settings' }\n    ],\n    'Select an option above'\n  );\n}\n\nasync function showWalletMenu(user: any) {\n  await sendButtonMessage(\n    user.whatsapp_number,\n    'üí∞ *Wallet Menu*\\n\\nManage your crypto wallet:',\n    [\n      { id: 'balance', title: 'üí∞ Balance' },\n      { id: 'send', title: 'üì§ Send' },\n      { id: 'receive', title: 'üì• Receive' }\n    ],\n    'Type *menu* for home'\n  );\n}\n\nasync function showMoneySavingsMenu(user: any) {\n  await sendButtonMessage(\n    user.whatsapp_number,\n    'üí≥ *Money & Savings*\\n\\nMobile money and group savings:',\n    [\n      { id: 'mobile_money', title: 'üí≥ Mobile Money' },\n      { id: 'chama', title: 'üë• Chama' },\n      { id: 'loans', title: 'üíµ Loans' }\n    ],\n    'Type *menu* for home'\n  );\n}\n\nasync function showMobileMoneyMenu(user: any) {\n  await sendButtonMessage(\n    user.whatsapp_number,\n    'üí≥ *Mobile Money*\\n\\nM-Pesa transactions:',\n    [\n      { id: 'deposit', title: 'üí≥ Deposit' },\n      { id: 'withdraw', title: 'üí∏ Withdraw' },\n      { id: 'menu', title: 'üè† Home' }\n    ],\n    'Deposit or withdraw with M-Pesa'\n  );\n}\n\nasync function showSettingsMenu(user: any) {\n  await sendButtonMessage(\n    user.whatsapp_number,\n    '‚öôÔ∏è *Settings*\\n\\nAccount management:',\n    [\n      { id: 'history', title: 'üìä History' },\n      { id: 'recover', title: 'üîë Recovery' },\n      { id: 'menu', title: 'üè† Home' }\n    ],\n    'Manage your account'\n  );\n}\n\nasync function handleSendCommand(user: any) {\n  try {\n    await createSession({\n      user_id: user.id,\n      session_type: 'send_crypto',\n      current_step: 'ask_token',\n      session_data: {},\n    });\n\n    await sendButtonMessage(\n      user.whatsapp_number,\n      'üì§ *Send Crypto*\\n\\nSelect token:',\n      [\n        { id: 'send_eth', title: 'ETH' },\n        { id: 'send_tzs', title: 'TZS' },\n      ]\n    );\n  } catch (error) {\n    console.error('Error starting send:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error starting send.');\n  }\n}\n\nasync function handleReceiveCommand(user: any) {\n  try {\n    const message = `üì• *Receive Crypto*\n\nShare this address:\n\\`${user.wallet_address}\\`\n\nNetwork: Scroll Sepolia Testnet\n\n*Supported:*\n‚Ä¢ ETH (Native)\n‚Ä¢ TZS (ERC20)\n\nAnyone can send to this address!`;\n\n    await sendButtonMessage(\n      user.whatsapp_number,\n      message,\n      [\n        { id: 'balance', title: 'üí∞ Balance' },\n        { id: 'send', title: 'üì§ Send' },\n        { id: 'menu', title: 'üè† Home' }\n      ],\n      'What would you like to do?'\n    );\n  } catch (error) {\n    console.error('Error in receive:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error.');\n  }\n}\n\nasync function handleHistoryCommand(user: any) {\n  try {\n    const transactions = await getTransactionsByUser(user.id, 10);\n    if (transactions.length === 0) {\n      await sendButtonMessage(\n        user.whatsapp_number,\n        'üìä *Transaction History*\\n\\nNo transactions yet.\\n\\nStart by depositing or receiving crypto!',\n        [\n          { id: 'deposit', title: 'üí≥ Deposit' },\n          { id: 'receive', title: 'üì• Receive' },\n          { id: 'menu', title: 'üè† Home' }\n        ]\n      );\n      return;\n    }\n\n    let message = 'üìä *Transaction History*\\n\\nLast 10 transactions:\\n\\n';\n\n    for (const tx of transactions.slice(0, 5)) {\n      const type = tx.from_user_id === user.id ? 'Sent' : 'Received';\n      const emoji = type === 'Sent' ? 'üì§' : 'üì•';\n      const address = type === 'Sent' ?\n        `To: ${tx.to_address.slice(0, 8)}...${tx.to_address.slice(-6)}` :\n        `From: ${tx.from_user_id ? 'User' : 'External'}`;\n\n      const tzsValue = tx.token_symbol === 'ETH'\n        ? await convertCurrency(parseFloat(tx.amount), 'ETH', 'TZS')\n        : parseFloat(tx.amount);\n      const usdValue = await convertCurrency(tzsValue, 'TZS', 'USD');\n\n      message += `${emoji} ${type} ${tx.token_symbol}\\n`;\n      message += ` ${formatBalance(tx.amount)} ${tx.token_symbol}\\n`;\n      message += ` ‚âà ${formatTZS(tzsValue)} TZS ‚âà $${formatUSD(usdValue)}\\n`;\n      message += ` ${address}\\n`;\n      message += ` ${new Date(tx.created_at).toLocaleDateString()}\\n\\n`;\n    }\n\n    await sendButtonMessage(\n      user.whatsapp_number,\n      message.trim(),\n      [\n        { id: 'send', title: 'üì§ Send' },\n        { id: 'balance', title: 'üí∞ Balance' },\n        { id: 'menu', title: 'üè† Home' }\n      ],\n      'View more in full history'\n    );\n  } catch (error) {\n    console.error('Error fetching history:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error fetching history.');\n  }\n}\n\nasync function handleRecoveryCommand(user: any) {\n  try {\n    await createSession({\n      user_id: user.id,\n      session_type: 'recovery',\n      current_step: 'verify_pin',\n      session_data: {},\n    });\n    await sendWhatsAppMessage(user.whatsapp_number, 'üîê *Wallet Recovery*\\n\\nEnter your PIN:');\n  } catch (error) {\n    console.error('Error starting recovery:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error.');\n  }\n}\n\nasync function handleCommand(user: any, command: string) {\n  if (!user.pin_setup_completed) {\n    await sendWhatsAppMessage(user.whatsapp_number, 'üîê Complete PIN setup first. Reply with a 4-6 digit PIN.');\n    await createSession({\n      user_id: user.id,\n      session_type: 'setup_pin',\n      current_step: 'ask_pin',\n      session_data: {},\n    });\n    return;\n  }\n\n  const commands: Record<string, (user: any) => Promise<void>> = {\n    'balance': handleBalanceCommand,\n    'bal': handleBalanceCommand,\n    'menu': showMainMenu,\n    'home': showMainMenu,\n    'start': showMainMenu,\n    'help': showMainMenu,\n    'wallet_menu': showWalletMenu,\n    'money_savings': showMoneySavingsMenu,\n    'mobile_money': showMobileMoneyMenu,\n    'settings_menu': showSettingsMenu,\n    'send': handleSendCommand,\n    'receive': handleReceiveCommand,\n    'history': handleHistoryCommand,\n    'recover': handleRecoveryCommand,\n  };\n\n  if (command === 'deposit') {\n    await createSession({\n      user_id: user.id,\n      session_type: 'mobile_money_deposit',\n      current_step: 'ask_token',\n      session_data: {},\n    });\n    await sendButtonMessage(user.whatsapp_number, 'üí≥ *Deposit via M-Pesa*\\n\\nSelect token:', [\n      { id: 'deposit_eth', title: 'ETH' },\n      { id: 'deposit_tzs', title: 'TZS' },\n    ]);\n    return;\n  }\n\n  if (command === 'withdraw') {\n    await createSession({\n      user_id: user.id,\n      session_type: 'mobile_money_withdraw',\n      current_step: 'ask_token',\n      session_data: {},\n    });\n    await sendButtonMessage(user.whatsapp_number, 'üí∏ *Withdraw to M-Pesa*\\n\\nSelect token:', [\n      { id: 'withdraw_eth', title: 'ETH' },\n      { id: 'withdraw_tzs', title: 'TZS' },\n    ]);\n    return;\n  }\n\n  if (command === 'chama') {\n    await sendButtonMessage(\n      user.whatsapp_number,\n      'üë• *Chama - Group Savings*\\n\\nJoin or create a chama:',\n      [\n        { id: 'chama_create', title: '‚ûï Create' },\n        { id: 'chama_join', title: 'üîó Join' },\n        { id: 'chama_my', title: 'üìã My Chamas' }\n      ],\n      'Type *menu* for home'\n    );\n    return;\n  }\n\n  if (command === 'chama_my') {\n    const chamas = await getUserChamas(user.id);\n    if (chamas.length === 0) {\n      await sendButtonMessage(\n        user.whatsapp_number,\n        'üë• *My Chamas*\\n\\nNot a member yet.\\n\\nCreate or join a chama to start saving together!',\n        [\n          { id: 'chama_create', title: '‚ûï Create' },\n          { id: 'chama_join', title: 'üîó Join' },\n          { id: 'menu', title: 'üè† Home' }\n        ]\n      );\n      return;\n    }\n\n    let message = 'üë• *My Chamas*\\n\\n';\n    for (const membership of chamas) {\n      const chama = membership.chamas;\n      const tzsValue = parseFloat(membership.tzs_share || 0);\n      const usdValue = await convertCurrency(tzsValue, 'TZS', 'USD');\n\n      message += `*${chama.name}*\\n`;\n      message += ` Your share: ${formatBalance(membership.tzs_share || 0)} TZS\\n`;\n      message += ` ‚âà $${formatUSD(usdValue)} USD\\n`;\n      message += ` Code: ${chama.invite_code}\\n\\n`;\n    }\n\n    await sendButtonMessage(\n      user.whatsapp_number,\n      message.trim(),\n      [\n        { id: 'chama_contribute', title: 'üí∞ Contribute' },\n        { id: 'loan_request', title: 'üíµ Request Loan' },\n        { id: 'chama', title: 'üë• Chama Menu' }\n      ],\n      'Manage your chamas'\n    );\n    return;\n  }\n\n  if (command === 'chama_create') {\n    await createSession({\n      user_id: user.id,\n      session_type: 'chama_create',\n      current_step: 'ask_name',\n      session_data: {},\n    });\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ûï *Create Chama*\\n\\nEnter Chama name:');\n    return;\n  }\n\n  if (command === 'chama_join') {\n    await createSession({\n      user_id: user.id,\n      session_type: 'chama_join',\n      current_step: 'ask_code',\n      session_data: {},\n    });\n    await sendWhatsAppMessage(user.whatsapp_number, 'üîó *Join Chama*\\n\\nEnter invite code:');\n    return;\n  }\n\n  if (command === 'chama_contribute') {\n    const chamas = await getUserChamas(user.id);\n    if (chamas.length === 0) {\n      await sendWhatsAppMessage(user.whatsapp_number, 'üí∞ *Contribute*\\n\\nJoin a Chama first.\\n\\nType *chama* to start.');\n      return;\n    }\n\n    await createSession({\n      user_id: user.id,\n      session_type: 'chama_contribute',\n      current_step: 'select_chama',\n      session_data: { chamas },\n    });\n\n    const sections = [{\n      title: 'Your Chamas',\n      rows: chamas.map((m: any) => ({\n        id: `chama_${m.chama_id}`,\n        title: m.chamas.name,\n        description: `Code: ${m.chamas.invite_code}`,\n      })),\n    }];\n\n    await sendListMessage(user.whatsapp_number, 'üí∞ *Contribute*\\n\\nSelect Chama:', 'Select', sections);\n    return;\n  }\n\n  if (command === 'loans') {\n    await sendButtonMessage(\n      user.whatsapp_number,\n      'üíµ *Loans*\\n\\nBorrow from your chama:',\n      [\n        { id: 'loan_request', title: 'üí∞ Request Loan' },\n        { id: 'loan_my', title: 'üìã My Loans' },\n        { id: 'loan_pending', title: '‚è≥ Pending' }\n      ],\n      'Type *menu* for home'\n    );\n    return;\n  }\n\n  if (command === 'loan_my') {\n    const loans = await getChamaLoans(null, user.id);\n    if (loans.length === 0) {\n      await sendButtonMessage(\n        user.whatsapp_number,\n        'üìã *My Loans*\\n\\nNo loans yet.\\n\\nRequest a loan from your chama to get started!',\n        [\n          { id: 'loan_request', title: 'üí∞ Request Loan' },\n          { id: 'chama_my', title: 'üë• My Chamas' },\n          { id: 'menu', title: 'üè† Home' }\n        ]\n      );\n      return;\n    }\n\n    let message = 'üìã *My Loans*\\n\\n';\n    for (const loan of loans) {\n      const tzsValue = parseFloat(loan.outstanding_balance);\n      const usdValue = await convertCurrency(tzsValue, 'TZS', 'USD');\n\n      message += `*${loan.chamas.name}*\\n`;\n      message += ` Outstanding: ${formatBalance(loan.outstanding_balance)} TZS\\n`;\n      message += ` ‚âà $${formatUSD(usdValue)} USD\\n`;\n      message += ` Interest: ${loan.interest_rate}%\\n`;\n      message += ` Status: ${loan.status}\\n\\n`;\n    }\n    await sendWhatsAppMessage(user.whatsapp_number, message.trim());\n    return;\n  }\n\n  if (command === 'loan_request') {\n    const chamas = await getUserChamas(user.id);\n    if (chamas.length === 0) {\n      await sendWhatsAppMessage(user.whatsapp_number, 'üìù *Request Loan*\\n\\nJoin a Chama first.\\n\\nType *chama*.');\n      return;\n    }\n\n    await createSession({\n      user_id: user.id,\n      session_type: 'loan_request',\n      current_step: 'select_chama',\n      session_data: { chamas },\n    });\n\n    const sections = [{\n      title: 'Your Chamas',\n      rows: chamas.map((m: any) => ({\n        id: `loan_chama_${m.chama_id}`,\n        title: m.chamas.name,\n        description: `Available funds`,\n      })),\n    }];\n\n    await sendListMessage(user.whatsapp_number, 'üìù *Request Loan*\\n\\nSelect Chama:', 'Select', sections);\n    return;\n  }\n\n  if (command === 'loan_pay') {\n    const loans = await getChamaLoans(null, user.id);\n    const activeLoans = loans.filter((loan: any) => loan.status === 'active');\n\n    if (activeLoans.length === 0) {\n      await sendWhatsAppMessage(user.whatsapp_number, 'üí≥ *Pay Loan*\\n\\nNo active loans.');\n      return;\n    }\n\n    await createSession({\n      user_id: user.id,\n      session_type: 'loan_pay',\n      current_step: 'select_loan',\n      session_data: { loans: activeLoans },\n    });\n\n    const sections = [{\n      title: 'Active Loans',\n      rows: activeLoans.map((loan: any, idx: number) => ({\n        id: `pay_loan_${idx}`,\n        title: `${loan.chamas.name}`,\n        description: `Balance: ${formatBalance(loan.outstanding_balance)} TZS`,\n      })),\n    }];\n\n    await sendListMessage(user.whatsapp_number, 'üí≥ *Pay Loan*\\n\\nSelect loan:', 'Select', sections);\n    return;\n  }\n\n  const handler = commands[command];\n  if (handler) {\n    await handler(user);\n  } else {\n    await showMainMenu(user);\n  }\n}\n\n// ============================================================================\n// SESSION HANDLERS\n// ============================================================================\nasync function handlePinSetupSession(user: any, session: any, messageText: string) {\n  const currentStep = session.current_step;\n  const sessionData = session.session_data || {};\n\n  try {\n    if (currentStep === 'ask_pin') {\n      const pin = messageText.trim();\n      if (!isValidPinFormat(pin)) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Invalid PIN. Enter 4-6 digits:');\n        return;\n      }\n      sessionData.pin = pin;\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'confirm_pin',\n      });\n      await sendWhatsAppMessage(user.whatsapp_number, 'üîê Confirm your PIN:');\n    } else if (currentStep === 'confirm_pin') {\n      const confirmPin = messageText.trim();\n      if (confirmPin !== sessionData.pin) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå PINs do not match. Enter new PIN (4-6 digits):');\n        await updateSession(session.id, {\n          session_data: {},\n          current_step: 'ask_pin',\n        });\n        return;\n      }\n\n      const hashedPin = hashPin(sessionData.pin);\n      await createUserPin({\n        user_id: user.id,\n        encrypted_pin: hashedPin,\n        failed_attempts: 0,\n      });\n\n      await updateUser(user.id, { pin_setup_completed: true, is_onboarded: true });\n      await sendWhatsAppMessage(user.whatsapp_number, '‚úÖ *PIN created!*\\n\\nWallet is ready.\\n\\nType *menu* to start!');\n      await deleteSession(session.id);\n    }\n  } catch (error) {\n    console.error('Error in PIN setup:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error setting up PIN.');\n    await deleteSession(session.id);\n  }\n}\n\nasync function handleSendCryptoSession(user: any, session: any, messageText: string) {\n  const currentStep = session.current_step;\n  const sessionData = session.session_data || {};\n\n  try {\n    if (currentStep === 'ask_token') {\n      if (messageText === 'send_eth') {\n        sessionData.tokenSymbol = 'ETH';\n      } else if (messageText === 'send_tzs') {\n        sessionData.tokenSymbol = 'TZS';\n      } else {\n        await sendWhatsAppMessage(user.whatsapp_number, 'Select ETH or TZS');\n        return;\n      }\n\n      const balances = await getAllBalances(user.wallet_address);\n      const balance = sessionData.tokenSymbol === 'ETH' ? balances.eth : balances.tzs;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'ask_recipient',\n      });\n\n      await sendWhatsAppMessage(\n        user.whatsapp_number,\n        `üì§ *Send ${sessionData.tokenSymbol}*\\n\\nBalance: ${formatBalance(balance)} ${sessionData.tokenSymbol}\\n\\nEnter recipient (address or phone):` );\n    } else if (currentStep === 'ask_recipient') {\n      const input = messageText.trim();\n      let recipientAddress = '';\n      let recipientUser = null;\n\n      if (/^\\d+$/.test(input)) {\n        recipientUser = await getUserByPhone(input);\n        if (recipientUser) {\n          recipientAddress = recipientUser.wallet_address;\n          sessionData.recipientUserId = recipientUser.id;\n          sessionData.recipientPhone = input;\n        } else {\n          await sendWhatsAppMessage(user.whatsapp_number, '‚ùå No wallet for this number.');\n          await deleteSession(session.id);\n          return;\n        }\n      } else if (isValidAddress(input)) {\n        recipientAddress = input;\n      } else {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Invalid address or phone.');\n        return;\n      }\n\n      sessionData.toAddress = recipientAddress;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'ask_amount',\n      });\n\n      await sendWhatsAppMessage(user.whatsapp_number, `üí∞ Enter amount of ${sessionData.tokenSymbol}:\\n\\nExample: 0.01`);\n    } else if (currentStep === 'ask_amount') {\n      const amount = parseFloat(messageText.trim());\n      if (isNaN(amount) || amount <= 0) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Invalid amount.');\n        return;\n      }\n\n      const balances = await getAllBalances(user.wallet_address);\n      const balance = sessionData.tokenSymbol === 'ETH' ? parseFloat(balances.eth) : parseFloat(balances.tzs);\n\n      if (amount > balance) {\n        await sendWhatsAppMessage(user.whatsapp_number, `‚ùå Insufficient: ${formatBalance(balance)} ${sessionData.tokenSymbol}`);\n        await deleteSession(session.id);\n        return;\n      }\n\n      sessionData.amount = amount.toString();\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'confirm',\n      });\n\n      const tzsValue = sessionData.tokenSymbol === 'ETH'\n        ? await convertCurrency(amount, 'ETH', 'TZS')\n        : amount;\n      const usdValue = await convertCurrency(tzsValue, 'TZS', 'USD');\n\n      const confirmMessage = `üì§ *Confirm*\n\nTo: \\`${sessionData.toAddress.slice(0, 10)}...${sessionData.toAddress.slice(-8)}\\`\n${sessionData.recipientPhone ? `Phone: ${sessionData.recipientPhone}\\n` : ''}\nAmount: ${formatBalance(amount)} ${sessionData.tokenSymbol}\n‚âà ${formatTZS(tzsValue)} TZS\n‚âà $${formatUSD(usdValue)} USD`;\n\n      await sendButtonMessage(user.whatsapp_number, confirmMessage, [\n        { id: 'confirm_yes', title: '‚úÖ Confirm' },\n        { id: 'confirm_no', title: '‚ùå Cancel' },\n      ]);\n    } else if (currentStep === 'confirm') {\n      if (messageText === 'confirm_yes') {\n        await updateSession(session.id, {\n          session_data: sessionData,\n          current_step: 'verify_pin',\n        });\n        await sendWhatsAppMessage(user.whatsapp_number, 'üîê Enter PIN:');\n      } else {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Cancelled.');\n        await deleteSession(session.id);\n      }\n    } else if (currentStep === 'verify_pin') {\n      const pin = messageText.trim();\n      const verifyResult = await verifyPin(user.id, pin);\n\n      if (!verifyResult.success) {\n        await sendWhatsAppMessage(user.whatsapp_number, `‚ùå ${verifyResult.error}`);\n        if (verifyResult.locked) {\n          await deleteSession(session.id);\n        }\n        return;\n      }\n\n      await sendWhatsAppMessage(user.whatsapp_number, '‚è≥ Processing...');\n\n      try {\n        const tx = await sendToken(\n          user.encrypted_private_key,\n          sessionData.toAddress,\n          sessionData.amount,\n          sessionData.tokenSymbol\n        );\n\n        const txData = {\n          tx_hash: tx.hash,\n          from_user_id: user.id,\n          to_user_id: sessionData.recipientUserId || null,\n          to_address: sessionData.toAddress,\n          amount: sessionData.amount,\n          token_symbol: sessionData.tokenSymbol,\n          status: 'pending',\n          network: NETWORK,\n        };\n\n        await createTransaction(txData);\n        balanceCache.delete(user.wallet_address);\n\n        const tzsValue = sessionData.tokenSymbol === 'ETH'\n          ? await convertCurrency(parseFloat(sessionData.amount), 'ETH', 'TZS')\n          : parseFloat(sessionData.amount);\n        const usdValue = await convertCurrency(tzsValue, 'TZS', 'USD');\n\n        const txMessage = `‚úÖ *Transaction Successful!*\n\nAmount: ${formatBalance(sessionData.amount)} ${sessionData.tokenSymbol}\n‚âà ${formatTZS(tzsValue)} TZS\n‚âà $${formatUSD(usdValue)} USD\n\nTx: ${tx.hash.slice(0, 10)}...${tx.hash.slice(-8)}\nView: ${SCROLL_SEPOLIA_EXPLORER}/tx/${tx.hash}`;\n\n        await sendButtonMessage(\n          user.whatsapp_number,\n          txMessage,\n          [\n            { id: 'balance', title: 'üí∞ Balance' },\n            { id: 'send', title: 'üì§ Send Again' },\n            { id: 'menu', title: 'üè† Home' }\n          ],\n          'What\\'s next?'\n        );\n\n        if (sessionData.recipientUserId) {\n          await notifyTransaction(sessionData.recipientUserId, sessionData.amount, sessionData.tokenSymbol, user);\n          balanceCache.delete(sessionData.toAddress);\n        }\n\n        try {\n          const receipt = await tx.wait(1);\n          if (receipt && receipt.status === 1) {\n            await sendWhatsAppMessage(user.whatsapp_number, '‚úÖ Confirmed on blockchain!');\n          }\n        } catch (waitError) {\n          console.error('Confirmation wait error:', waitError);\n        }\n\n        await deleteSession(session.id);\n      } catch (txError: any) {\n        console.error('Transaction error:', txError);\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Transaction failed.');\n        await deleteSession(session.id);\n      }\n    }\n  } catch (error) {\n    console.error('Error in send session:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error.');\n    await deleteSession(session.id);\n  }\n}\n\nasync function handleMobileMoneyDepositSession(user: any, session: any, messageText: string) {\n  const currentStep = session.current_step;\n  const sessionData = session.session_data || {};\n\n  try {\n    if (currentStep === 'ask_token') {\n      if (messageText === 'deposit_eth') {\n        sessionData.tokenSymbol = 'ETH';\n      } else if (messageText === 'deposit_tzs') {\n        sessionData.tokenSymbol = 'TZS';\n      } else {\n        await sendWhatsAppMessage(user.whatsapp_number, 'Select ETH or TZS');\n        return;\n      }\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'ask_amount',\n      });\n\n      const rates = await fetchRealTimeFXRates();\n      const minTzs = 1000;\n\n      await sendWhatsAppMessage(\n        user.whatsapp_number,\n        `üí≥ *Deposit via M-Pesa*\\n\\nEnter TZS amount (min ${formatTZS(minTzs)}):\\n\\nRate: 1 ETH = ${formatTZS(rates.ETH_TZS)} TZS`\n      );\n    } else if (currentStep === 'ask_amount') {\n      const tzsAmount = parseInt(messageText.trim());\n\n      if (isNaN(tzsAmount) || tzsAmount < 1000) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Minimum 1,000 TZS.');\n        return;\n      }\n\n      sessionData.tzsAmount = tzsAmount;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'ask_phone',\n      });\n\n      await sendWhatsAppMessage(user.whatsapp_number, 'üì± Enter M-Pesa phone:\\n\\nExample: 255712345678');\n    } else if (currentStep === 'ask_phone') {\n      const phoneNumber = messageText.trim();\n\n      if (!/^255\\d{9}$/.test(phoneNumber)) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Invalid: 255XXXXXXXXX');\n        return;\n      }\n\n      sessionData.phoneNumber = phoneNumber;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'confirm',\n      });\n\n      const cryptoAmount = sessionData.tokenSymbol === 'ETH'\n        ? await convertCurrency(sessionData.tzsAmount, 'TZS', 'ETH')\n        : sessionData.tzsAmount;\n      const usdValue = await convertCurrency(sessionData.tzsAmount, 'TZS', 'USD');\n\n      sessionData.cryptoAmount = cryptoAmount;\n\n      const confirmMessage = `üí≥ *Confirm Deposit*\n\nAmount: ${formatTZS(sessionData.tzsAmount)} TZS\n‚âà $${formatUSD(usdValue)} USD\n\nYou'll receive:\n${formatBalance(cryptoAmount)} ${sessionData.tokenSymbol}\n\nPhone: ${phoneNumber}`;\n\n      await sendButtonMessage(user.whatsapp_number, confirmMessage, [\n        { id: 'confirm_yes', title: '‚úÖ Confirm' },\n        { id: 'confirm_no', title: '‚ùå Cancel' },\n      ]);\n    } else if (currentStep === 'confirm') {\n      if (messageText === 'confirm_yes') {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚è≥ Processing...');\n\n        const orderId = generateOrderId(user.id);\n\n        const txData = {\n          user_id: user.id,\n          order_id: orderId,\n          transaction_type: 'deposit',\n          token_symbol: sessionData.tokenSymbol,\n          amount_tzs: sessionData.tzsAmount,\n          amount_crypto: sessionData.cryptoAmount,\n          phone_number: sessionData.phoneNumber,\n          payment_channel: 'MPESA-TZ',\n          status: 'pending',\n        };\n\n        await createMobileMoneyTransaction(txData);\n\n        const zenoResult = await createDepositOrder(\n          orderId,\n          sessionData.phoneNumber,\n          sessionData.tzsAmount\n        );\n\n        if (zenoResult.success) {\n          await sendWhatsAppMessage(\n            user.whatsapp_number,\n            `‚úÖ *Deposit Initiated!*\\n\\nYou'll receive ${formatBalance(sessionData.cryptoAmount)} ${sessionData.tokenSymbol}\\n\\nComplete M-Pesa prompt.`\n          );\n        } else {\n          await sendWhatsAppMessage(user.whatsapp_number, `‚ùå Failed: ${zenoResult.error}`);\n        }\n\n        await deleteSession(session.id);\n      } else {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Cancelled.');\n        await deleteSession(session.id);\n      }\n    }\n  } catch (error) {\n    console.error('Error in deposit session:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error.');\n    await deleteSession(session.id);\n  }\n}\n\nasync function handleMobileMoneyWithdrawSession(user: any, session: any, messageText: string) {\n  const currentStep = session.current_step;\n  const sessionData = session.session_data || {};\n\n  try {\n    if (currentStep === 'ask_token') {\n      if (messageText === 'withdraw_eth') {\n        sessionData.tokenSymbol = 'ETH';\n      } else if (messageText === 'withdraw_tzs') {\n        sessionData.tokenSymbol = 'TZS';\n      } else {\n        await sendWhatsAppMessage(user.whatsapp_number, 'Select ETH or TZS');\n        return;\n      }\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'ask_amount',\n      });\n\n      const balances = await getAllBalances(user.wallet_address);\n      const balance = sessionData.tokenSymbol === 'ETH' ? balances.eth : balances.tzs;\n\n      await sendWhatsAppMessage(\n        user.whatsapp_number,\n        `üí∏ *Withdraw to M-Pesa*\\n\\nBalance: ${formatBalance(balance)} ${sessionData.tokenSymbol}\\n\\nEnter amount:`\n      );\n    } else if (currentStep === 'ask_amount') {\n      const cryptoAmount = parseFloat(messageText.trim());\n\n      if (isNaN(cryptoAmount) || cryptoAmount <= 0) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Invalid amount.');\n        return;\n      }\n\n      const balances = await getAllBalances(user.wallet_address);\n      const balance = sessionData.tokenSymbol === 'ETH' ? parseFloat(balances.eth) : parseFloat(balances.tzs);\n\n      if (cryptoAmount > balance) {\n        await sendWhatsAppMessage(user.whatsapp_number, `‚ùå Insufficient: ${formatBalance(balance)} ${sessionData.tokenSymbol}`);\n        await deleteSession(session.id);\n        return;\n      }\n\n      sessionData.cryptoAmount = cryptoAmount;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'ask_phone',\n      });\n\n      await sendWhatsAppMessage(user.whatsapp_number, 'üì± Enter M-Pesa phone:\\n\\nExample: 255712345678');\n    } else if (currentStep === 'ask_phone') {\n      const phoneNumber = messageText.trim();\n\n      if (!/^255\\d{9}$/.test(phoneNumber)) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Invalid: 255XXXXXXXXX');\n        return;\n      }\n\n      sessionData.phoneNumber = phoneNumber;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'confirm',\n      });\n\n      const tzsAmount = sessionData.tokenSymbol === 'ETH'\n        ? Math.round(await convertCurrency(sessionData.cryptoAmount, 'ETH', 'TZS'))\n        : Math.round(sessionData.cryptoAmount);\n      const usdValue = await convertCurrency(tzsAmount, 'TZS', 'USD');\n\n      sessionData.tzsAmount = tzsAmount;\n\n      const confirmMessage = `üí∏ *Confirm Withdrawal*\n\nAmount: ${formatBalance(sessionData.cryptoAmount)} ${sessionData.tokenSymbol}\n\nYou'll receive:\n${formatTZS(tzsAmount)} TZS\n‚âà $${formatUSD(usdValue)} USD\n\nPhone: ${phoneNumber}`;\n\n      await sendButtonMessage(user.whatsapp_number, confirmMessage, [\n        { id: 'confirm_yes', title: '‚úÖ Confirm' },\n        { id: 'confirm_no', title: '‚ùå Cancel' },\n      ]);\n    } else if (currentStep === 'confirm') {\n      if (messageText === 'confirm_yes') {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚è≥ Processing...');\n\n        const orderId = generateOrderId(user.id);\n\n        const txData = {\n          user_id: user.id,\n          order_id: orderId,\n          transaction_type: 'withdraw',\n          token_symbol: sessionData.tokenSymbol,\n          amount_tzs: sessionData.tzsAmount,\n          amount_crypto: sessionData.cryptoAmount,\n          phone_number: sessionData.phoneNumber,\n          payment_channel: 'MPESA-TZ',\n          status: 'pending',\n        };\n\n        await createMobileMoneyTransaction(txData);\n\n        const zenoResult = await createWithdrawalOrder(\n          orderId,\n          sessionData.phoneNumber,\n          sessionData.tzsAmount\n        );\n\n        if (zenoResult.success) {\n          await sendWhatsAppMessage(\n            user.whatsapp_number,\n            `‚úÖ *Withdrawal Initiated!*\\n\\nYou'll receive ${formatTZS(sessionData.tzsAmount)} TZS to ${sessionData.phoneNumber}`\n          );\n        } else {\n          await sendWhatsAppMessage(user.whatsapp_number, `‚ùå Failed: ${zenoResult.error}`);\n        }\n\n        await deleteSession(session.id);\n      } else {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Cancelled.');\n        await deleteSession(session.id);\n      }\n    }\n  } catch (error) {\n    console.error('Error in withdrawal session:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error.');\n    await deleteSession(session.id);\n  }\n}\n\nasync function handleChamaCreateSession(user: any, session: any, messageText: string) {\n  const currentStep = session.current_step;\n  const sessionData = session.session_data || {};\n\n  try {\n    if (currentStep === 'ask_name') {\n      sessionData.name = messageText.trim();\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'ask_description',\n      });\n\n      await sendWhatsAppMessage(user.whatsapp_number, 'Enter Chama description:');\n    } else if (currentStep === 'ask_description') {\n      sessionData.description = messageText.trim();\n\n      const inviteCode = await callDatabaseFunction('generate_invite_code', {});\n\n      const chamaData = {\n        name: sessionData.name,\n        description: sessionData.description,\n        invite_code: inviteCode,\n        creator_id: user.id,\n        share_price_usd: 10,\n        weekly_minimum_contribution: 5,\n        loan_interest_rate: 5,\n        lockup_period_months: 3,\n        auto_investment_percentage: 10,\n        status: 'active',\n        member_count: 1,\n        eth_pool: 0,\n        tzs_pool: 0,\n      };\n\n      const chama = await createChama(chamaData);\n\n      const memberData = {\n        chama_id: chama.id,\n        user_id: user.id,\n        is_admin: true,\n        status: 'active',\n        eth_share: 0,\n        tzs_share: 0,\n        total_contributions: 0,\n      };\n\n      await createChamaMember(memberData);\n\n      // Deploy smart contract on blockchain\n      await sendWhatsAppMessage(user.whatsapp_number, '‚è≥ Deploying smart contract on blockchain...');\n\n      const blockchainResult = await createChamaOnChain({\n        name: sessionData.name,\n        description: sessionData.description,\n        inviteCode: inviteCode,\n        sharePriceUSD: 10,\n        weeklyMinimum: 5,\n        loanInterestRate: 5,\n        lockupMonths: 3,\n      });\n\n      if (blockchainResult.success && blockchainResult.chamaAddress) {\n        // Update chama with blockchain details\n        await updateChama(chama.id, {\n          contract_address: blockchainResult.chamaAddress,\n          creation_tx_hash: blockchainResult.txHash,\n          creation_explorer_link: blockchainResult.explorerLink,\n        });\n\n        await sendWhatsAppMessage(\n          user.whatsapp_number,\n          `‚úÖ *Chama Created Successfully!*\\n\\n` +\n          `Name: ${sessionData.name}\\n` +\n          `Invite Code: *${inviteCode}*\\n` +\n          `Contract: ${blockchainResult.chamaAddress}\\n\\n` +\n          `üîç View on Explorer:\\n${blockchainResult.explorerLink}\\n\\n` +\n          `Share the invite code with members!`\n        );\n      } else {\n        await sendWhatsAppMessage(\n          user.whatsapp_number,\n          `‚úÖ *Chama Created!*\\n\\n` +\n          `Name: ${sessionData.name}\\n` +\n          `Invite Code: *${inviteCode}*\\n\\n` +\n          `‚ö†Ô∏è Blockchain deployment pending: ${blockchainResult.error}\\n\\n` +\n          `Share with members!`\n        );\n      }\n\n      await deleteSession(session.id);\n    }\n  } catch (error) {\n    console.error('Error creating Chama:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error creating Chama.');\n    await deleteSession(session.id);\n  }\n}\n\nasync function handleChamaJoinSession(user: any, session: any, messageText: string) {\n  try {\n    const inviteCode = messageText.trim().toUpperCase();\n    const chama = await getChamaByInviteCode(inviteCode);\n\n    if (!chama) {\n      await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Invalid code.');\n      await deleteSession(session.id);\n      return;\n    }\n\n    if (chama.status !== 'active') {\n      await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Chama not active.');\n      await deleteSession(session.id);\n      return;\n    }\n\n    const existingMember = await getChamaMemberByUserAndChama(user.id, chama.id);\n    if (existingMember) {\n      await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Already a member.');\n      await deleteSession(session.id);\n      return;\n    }\n\n    const memberData = {\n      chama_id: chama.id,\n      user_id: user.id,\n      is_admin: false,\n      status: 'active',\n      eth_share: 0,\n      tzs_share: 0,\n      total_contributions: 0,\n    };\n\n    await createChamaMember(memberData);\n    await updateChama(chama.id, {\n      member_count: chama.member_count + 1,\n    });\n\n    // Join chama on blockchain if contract exists\n    if (chama.contract_address) {\n      await sendWhatsAppMessage(user.whatsapp_number, '‚è≥ Joining on blockchain...');\n\n      const joinResult = await joinChamaOnChain(chama.contract_address);\n\n      if (joinResult.success) {\n        await sendWhatsAppMessage(\n          user.whatsapp_number,\n          `‚úÖ Joined ${chama.name}!\\n\\n` +\n          `üîç Transaction:\\n${joinResult.explorerLink}\\n\\n` +\n          `Type *chama* for options.`\n        );\n      } else {\n        await sendWhatsAppMessage(\n          user.whatsapp_number,\n          `‚úÖ Joined ${chama.name}!\\n\\n` +\n          `‚ö†Ô∏è Blockchain join pending: ${joinResult.error}\\n\\n` +\n          `Type *chama* for options.`\n        );\n      }\n    } else {\n      await sendWhatsAppMessage(user.whatsapp_number, `‚úÖ Joined ${chama.name}!\\n\\nType *chama* for options.`);\n    }\n\n    await notifyChamaMembers(\n      chama.id,\n      'New Member',\n      `üë• *${chama.name}*\\n\\nNew member joined: ${user.whatsapp_number}\\n\\nWelcome!`,\n      user.id\n    );\n\n    await deleteSession(session.id);\n  } catch (error) {\n    console.error('Error joining Chama:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error joining.');\n    await deleteSession(session.id);\n  }\n}\n\nasync function handleChamaContributeSession(user: any, session: any, messageText: string) {\n  const currentStep = session.current_step;\n  const sessionData = session.session_data || {};\n\n  try {\n    if (currentStep === 'select_chama') {\n      const chamaId = messageText.replace('chama_', '');\n      const chama = await getChamaById(chamaId);\n\n      if (!chama) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Chama not found.');\n        await deleteSession(session.id);\n        return;\n      }\n\n      sessionData.chamaId = chamaId;\n      sessionData.chamaName = chama.name;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'ask_token',\n      });\n\n      await sendButtonMessage(user.whatsapp_number, 'üí∞ *Contribute*\\n\\nSelect token:', [\n        { id: 'contribute_eth', title: 'ETH' },\n        { id: 'contribute_tzs', title: 'TZS' },\n      ]);\n    } else if (currentStep === 'ask_token') {\n      if (messageText === 'contribute_eth') {\n        sessionData.tokenSymbol = 'ETH';\n      } else if (messageText === 'contribute_tzs') {\n        sessionData.tokenSymbol = 'TZS';\n      } else {\n        await sendWhatsAppMessage(user.whatsapp_number, 'Select ETH or TZS');\n        return;\n      }\n\n      const balances = await getAllBalances(user.wallet_address);\n      const balance = sessionData.tokenSymbol === 'ETH' ? balances.eth : balances.tzs;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'ask_amount',\n      });\n\n      await sendWhatsAppMessage(\n        user.whatsapp_number,\n        `üí∞ *Contribute to ${sessionData.chamaName}*\\n\\nBalance: ${formatBalance(balance)} ${sessionData.tokenSymbol}\\n\\nEnter amount:`\n      );\n    } else if (currentStep === 'ask_amount') {\n      const amount = parseFloat(messageText.trim());\n\n      if (isNaN(amount) || amount <= 0) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Invalid amount.');\n        return;\n      }\n\n      const balances = await getAllBalances(user.wallet_address);\n      const balance = sessionData.tokenSymbol === 'ETH' ? parseFloat(balances.eth) : parseFloat(balances.tzs);\n\n      if (amount > balance) {\n        await sendWhatsAppMessage(user.whatsapp_number, `‚ùå Insufficient: ${formatBalance(balance)} ${sessionData.tokenSymbol}`);\n        await deleteSession(session.id);\n        return;\n      }\n\n      sessionData.amount = amount;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'verify_pin',\n      });\n\n      const tzsValue = sessionData.tokenSymbol === 'ETH'\n        ? await convertCurrency(amount, 'ETH', 'TZS')\n        : amount;\n      const usdValue = await convertCurrency(tzsValue, 'TZS', 'USD');\n\n      await sendWhatsAppMessage(\n        user.whatsapp_number,\n        `üí∞ *Confirm Contribution*\\n\\nChama: ${sessionData.chamaName}\\nAmount: ${formatBalance(amount)} ${sessionData.tokenSymbol}\\n‚âà ${formatTZS(tzsValue)} TZS\\n‚âà $${formatUSD(usdValue)} USD\\n\\nüîê Enter PIN:`\n      );\n    } else if (currentStep === 'verify_pin') {\n      const pin = messageText.trim();\n      const verifyResult = await verifyPin(user.id, pin);\n\n      if (!verifyResult.success) {\n        await sendWhatsAppMessage(user.whatsapp_number, `‚ùå ${verifyResult.error}`);\n        if (verifyResult.locked) await deleteSession(session.id);\n        return;\n      }\n\n      await sendWhatsAppMessage(user.whatsapp_number, '‚è≥ Processing...');\n\n      const chama = await getChamaById(sessionData.chamaId);\n      if (!chama) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Chama not found.');\n        await deleteSession(session.id);\n        return;\n      }\n\n      const member = await getChamaMemberByUserAndChama(user.id, sessionData.chamaId);\n      if (!member) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Not a member.');\n        await deleteSession(session.id);\n        return;\n      }\n\n      const tzsValue = sessionData.tokenSymbol === 'ETH'\n        ? await convertCurrency(sessionData.amount, 'ETH', 'TZS')\n        : sessionData.amount;\n      const usdValue = await convertCurrency(tzsValue, 'TZS', 'USD');\n\n      // Make on-chain contribution if contract exists\n      let explorerLink = '';\n      if (chama.contract_address) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚è≥ Processing blockchain transaction...');\n\n        const contributeResult = await contributeToChamaOnChain({\n          chamaAddress: chama.contract_address,\n          token: sessionData.tokenSymbol,\n          amount: sessionData.amount.toString(),\n          amountUSD: usdValue,\n        });\n\n        if (contributeResult.success) {\n          explorerLink = contributeResult.explorerLink || '';\n\n          // Record contribution in database\n          await createChamaContribution({\n            chama_id: sessionData.chamaId,\n            user_id: user.id,\n            member_id: member.id,\n            token_symbol: sessionData.tokenSymbol,\n            amount_crypto: sessionData.amount,\n            amount_usd: usdValue,\n            tx_hash: contributeResult.txHash,\n            explorer_link: explorerLink,\n            status: 'confirmed',\n            confirmed_at: new Date().toISOString(),\n          });\n\n          // Update member shares\n          if (sessionData.tokenSymbol === 'ETH') {\n            await updateChamaMember(member.id, {\n              eth_share: parseFloat(member.eth_share || 0) + sessionData.amount,\n              total_contributions: parseFloat(member.total_contributions || 0) + sessionData.amount\n            });\n            await updateChama(sessionData.chamaId, {\n              eth_pool: parseFloat(chama.eth_pool || 0) + sessionData.amount\n            });\n          } else {\n            await updateChamaMember(member.id, {\n              tzs_share: parseFloat(member.tzs_share || 0) + sessionData.amount,\n              total_contributions: parseFloat(member.total_contributions || 0) + sessionData.amount\n            });\n            await updateChama(sessionData.chamaId, {\n              tzs_pool: parseFloat(chama.tzs_pool || 0) + sessionData.amount\n            });\n          }\n        } else {\n          await sendWhatsAppMessage(user.whatsapp_number, `‚ùå Blockchain transaction failed: ${contributeResult.error}`);\n          await deleteSession(session.id);\n          return;\n        }\n      } else {\n        // Fallback to database-only if no contract\n        if (sessionData.tokenSymbol === 'ETH') {\n          await updateChamaMember(member.id, {\n            eth_share: parseFloat(member.eth_share || 0) + sessionData.amount,\n            total_contributions: parseFloat(member.total_contributions || 0) + sessionData.amount\n          });\n          await updateChama(sessionData.chamaId, {\n            eth_pool: parseFloat(chama.eth_pool || 0) + sessionData.amount\n          });\n        } else {\n          await updateChamaMember(member.id, {\n            tzs_share: parseFloat(member.tzs_share || 0) + sessionData.amount,\n            total_contributions: parseFloat(member.total_contributions || 0) + sessionData.amount\n          });\n          await updateChama(sessionData.chamaId, {\n            tzs_pool: parseFloat(chama.tzs_pool || 0) + sessionData.amount\n          });\n        }\n      }\n\n      await sendWhatsAppMessage(\n        user.whatsapp_number,\n        `‚úÖ *Contribution Success!*\\n\\n` +\n        `Chama: ${sessionData.chamaName}\\n` +\n        `Amount: ${formatBalance(sessionData.amount)} ${sessionData.tokenSymbol}\\n` +\n        `‚âà ${formatTZS(tzsValue)} TZS\\n` +\n        `‚âà $${formatUSD(usdValue)} USD\\n\\n` +\n        (explorerLink ? `üîç View Transaction:\\n${explorerLink}` : '')\n      );\n\n      // Notify members\n      await notifyChamaMembers(\n        sessionData.chamaId,\n        'New Contribution',\n        `üí∞ *${sessionData.chamaName}*\\n\\n${user.whatsapp_number} contributed ${formatBalance(sessionData.amount)} ${sessionData.tokenSymbol}\\n‚âà ${formatTZS(tzsValue)} TZS`,\n        user.id\n      );\n\n      await deleteSession(session.id);\n    }\n  } catch (error) {\n    console.error('Error in contribute session:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error.');\n    await deleteSession(session.id);\n  }\n}\n\nasync function handleLoanRequestSession(user: any, session: any, messageText: string) {\n  const currentStep = session.current_step;\n  const sessionData = session.session_data || {};\n\n  try {\n    if (currentStep === 'select_chama') {\n      const chamaId = messageText.replace('loan_chama_', '');\n      const chama = await getChamaById(chamaId);\n\n      if (!chama) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Chama not found.');\n        await deleteSession(session.id);\n        return;\n      }\n\n      sessionData.chamaId = chamaId;\n      sessionData.chamaName = chama.name;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'ask_amount',\n      });\n\n      const tzsPool = parseFloat(chama.tzs_pool || 0);\n      const usdPool = await convertCurrency(tzsPool, 'TZS', 'USD');\n\n      await sendWhatsAppMessage(\n        user.whatsapp_number,\n        `üìù *Request Loan*\\n\\nChama: ${chama.name}\\nAvailable: ${formatTZS(tzsPool)} TZS (‚âà $${formatUSD(usdPool)})\\n\\nEnter loan amount in TZS:`\n      );\n    } else if (currentStep === 'ask_amount') {\n      const amount = parseFloat(messageText.trim());\n\n      if (isNaN(amount) || amount <= 0) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Invalid amount.');\n        return;\n      }\n\n      const chama = await getChamaById(sessionData.chamaId);\n      const availableTzs = parseFloat(chama.tzs_pool || 0);\n\n      if (amount > availableTzs) {\n        await sendWhatsAppMessage(\n          user.whatsapp_number,\n          `‚ùå Insufficient funds. Available: ${formatTZS(availableTzs)} TZS`\n        );\n        await deleteSession(session.id);\n        return;\n      }\n\n      sessionData.amount = amount;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'ask_duration',\n      });\n\n      await sendWhatsAppMessage(user.whatsapp_number, 'Enter loan duration in months (e.g., 3, 6, 12):');\n    } else if (currentStep === 'ask_duration') {\n      const duration = parseInt(messageText.trim());\n\n      if (isNaN(duration) || duration < 1) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Invalid duration.');\n        return;\n      }\n\n      sessionData.duration = duration;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'verify_pin',\n      });\n\n      const usdValue = await convertCurrency(sessionData.amount, 'TZS', 'USD');\n      const chama = await getChamaById(sessionData.chamaId);\n      const interestRate = chama.loan_interest_rate || 5;\n      const totalWithInterest = sessionData.amount * (1 + interestRate / 100);\n\n      await sendWhatsAppMessage(\n        user.whatsapp_number,\n        `üìù *Confirm Loan Request*\\n\\nChama: ${sessionData.chamaName}\\nAmount: ${formatTZS(sessionData.amount)} TZS (‚âà $${formatUSD(usdValue)})\\nDuration: ${duration} months\\nInterest: ${interestRate}%\\nTotal Repay: ${formatTZS(totalWithInterest)} TZS\\n\\nüîê Enter PIN:`\n      );\n    } else if (currentStep === 'verify_pin') {\n      const pin = messageText.trim();\n      const verifyResult = await verifyPin(user.id, pin);\n\n      if (!verifyResult.success) {\n        await sendWhatsAppMessage(user.whatsapp_number, `‚ùå ${verifyResult.error}`);\n        if (verifyResult.locked) await deleteSession(session.id);\n        return;\n      }\n\n      await sendWhatsAppMessage(user.whatsapp_number, '‚è≥ Processing...');\n\n      const chama = await getChamaById(sessionData.chamaId);\n      const member = await getChamaMemberByUserAndChama(user.id, sessionData.chamaId);\n\n      // Get all members for approval\n      const { data: allMembers } = await supabase\n        .from('chama_members')\n        .select('id')\n        .eq('chama_id', sessionData.chamaId)\n        .eq('status', 'active');\n\n      const interestRate = chama.loan_interest_rate || 5;\n      const totalWithInterest = sessionData.amount * (1 + interestRate / 100);\n\n      const loanData = {\n        chama_id: sessionData.chamaId,\n        borrower_id: user.id,\n        loan_amount: sessionData.amount,\n        outstanding_balance: totalWithInterest,\n        interest_rate: interestRate,\n        duration_months: sessionData.duration,\n        token_symbol: 'TZS',\n        status: 'pending',\n        approvals_required: allMembers?.length || 1,\n        approvals_received: 0,\n        denials_received: 0,\n      };\n\n      const loan = await createLoan(loanData);\n\n      await sendWhatsAppMessage(\n        user.whatsapp_number,\n        `‚úÖ *Loan Request Submitted!*\\n\\nAmount: ${formatTZS(sessionData.amount)} TZS\\n\\nWaiting for member approval.`\n      );\n\n      // Notify all members\n      const usdValue = await convertCurrency(sessionData.amount, 'TZS', 'USD');\n      await notifyChamaMembers(\n        sessionData.chamaId,\n        'Loan Request',\n        `üíµ *${sessionData.chamaName}*\\n\\nLoan Request from ${user.whatsapp_number}\\n\\nAmount: ${formatTZS(sessionData.amount)} TZS (‚âà $${formatUSD(usdValue)})\\nDuration: ${sessionData.duration} months\\n\\nReply *approve_${loan.id}* to approve\\nReply *deny_${loan.id}* to deny`,\n        user.id\n      );\n\n      await deleteSession(session.id);\n    }\n  } catch (error) {\n    console.error('Error in loan request session:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error.');\n    await deleteSession(session.id);\n  }\n}\n\nasync function handleLoanPaySession(user: any, session: any, messageText: string) {\n  const currentStep = session.current_step;\n  const sessionData = session.session_data || {};\n\n  try {\n    if (currentStep === 'select_loan') {\n      const loanIndex = parseInt(messageText.replace('pay_loan_', ''));\n      const loan = sessionData.loans[loanIndex];\n\n      if (!loan) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Loan not found.');\n        await deleteSession(session.id);\n        return;\n      }\n\n      sessionData.loanId = loan.id;\n      sessionData.outstanding = loan.outstanding_balance;\n      sessionData.chamaName = loan.chamas.name;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'ask_amount',\n      });\n\n      const usdValue = await convertCurrency(loan.outstanding_balance, 'TZS', 'USD');\n\n      await sendWhatsAppMessage(\n        user.whatsapp_number,\n        `üí≥ *Pay Loan*\\n\\nChama: ${loan.chamas.name}\\nOutstanding: ${formatTZS(loan.outstanding_balance)} TZS (‚âà $${formatUSD(usdValue)})\\n\\nEnter payment amount in TZS:`\n      );\n    } else if (currentStep === 'ask_amount') {\n      const amount = parseFloat(messageText.trim());\n\n      if (isNaN(amount) || amount <= 0) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Invalid amount.');\n        return;\n      }\n\n      if (amount > sessionData.outstanding) {\n        await sendWhatsAppMessage(\n          user.whatsapp_number,\n          `‚ùå Amount exceeds outstanding: ${formatTZS(sessionData.outstanding)} TZS`\n        );\n        return;\n      }\n\n      sessionData.amount = amount;\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'verify_pin',\n      });\n\n      const usdValue = await convertCurrency(amount, 'TZS', 'USD');\n\n      await sendWhatsAppMessage(\n        user.whatsapp_number,\n        `üí≥ *Confirm Payment*\\n\\nChama: ${sessionData.chamaName}\\nAmount: ${formatTZS(amount)} TZS (‚âà $${formatUSD(usdValue)})\\n\\nüîê Enter PIN:`\n      );\n    } else if (currentStep === 'verify_pin') {\n      const pin = messageText.trim();\n      const verifyResult = await verifyPin(user.id, pin);\n\n      if (!verifyResult.success) {\n        await sendWhatsAppMessage(user.whatsapp_number, `‚ùå ${verifyResult.error}`);\n        if (verifyResult.locked) await deleteSession(session.id);\n        return;\n      }\n\n      await sendWhatsAppMessage(user.whatsapp_number, '‚è≥ Processing...');\n\n      // Update loan\n      const newBalance = sessionData.outstanding - sessionData.amount;\n      const updates: any = {\n        outstanding_balance: newBalance\n      };\n\n      if (newBalance <= 0) {\n        updates.status = 'paid';\n      }\n\n      await updateLoan(sessionData.loanId, updates);\n\n      await sendWhatsAppMessage(\n        user.whatsapp_number,\n        `‚úÖ *Payment Success!*\\n\\nPaid: ${formatTZS(sessionData.amount)} TZS\\nRemaining: ${formatTZS(newBalance)} TZS${newBalance <= 0 ? '\\n\\nüéâ Loan fully paid!' : ''}`\n      );\n\n      await deleteSession(session.id);\n    }\n  } catch (error) {\n    console.error('Error in loan pay session:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error.');\n    await deleteSession(session.id);\n  }\n}\n\nasync function handleRecoverySession(user: any, session: any, messageText: string) {\n  const currentStep = session.current_step;\n  const sessionData = session.session_data || {};\n\n  try {\n    if (currentStep === 'verify_pin') {\n      const pin = messageText.trim();\n      const verifyResult = await verifyPin(user.id, pin);\n\n      if (!verifyResult.success) {\n        await sendWhatsAppMessage(user.whatsapp_number, `‚ùå ${verifyResult.error}`);\n        if (verifyResult.locked) await deleteSession(session.id);\n        return;\n      }\n\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'show_options',\n      });\n\n      await sendButtonMessage(user.whatsapp_number, 'üîë *Recovery Options*\\n\\nSelect:', [\n        { id: 'recover_mnemonic', title: 'Recovery Phrase' },\n        { id: 'change_pin', title: 'Change PIN' },\n      ]);\n    } else if (currentStep === 'show_options') {\n      if (messageText === 'recover_mnemonic') {\n        const mnemonic = decrypt(user.encrypted_mnemonic);\n        await sendWhatsAppMessage(\n          user.whatsapp_number,\n          `‚ö†Ô∏è *IMPORTANT*\\n\\nYour recovery phrase:\\n\\`${mnemonic}\\`\\n\\n‚Ä¢ Never share\\n‚Ä¢ Store safely\\n‚Ä¢ Anyone with this can access funds`\n        );\n        await deleteSession(session.id);\n      } else if (messageText === 'change_pin') {\n        await updateSession(session.id, {\n          session_data: {},\n          current_step: 'ask_new_pin',\n        });\n        await sendWhatsAppMessage(user.whatsapp_number, 'üîê *Change PIN*\\n\\nEnter new PIN (4-6 digits):');\n      }\n    } else if (currentStep === 'ask_new_pin') {\n      const pin = messageText.trim();\n      if (!isValidPinFormat(pin)) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Invalid. Enter 4-6 digits:');\n        return;\n      }\n      sessionData.newPin = pin;\n      await updateSession(session.id, {\n        session_data: sessionData,\n        current_step: 'confirm_new_pin',\n      });\n      await sendWhatsAppMessage(user.whatsapp_number, 'üîê Confirm new PIN:');\n    } else if (currentStep === 'confirm_new_pin') {\n      const confirmPin = messageText.trim();\n      if (confirmPin !== sessionData.newPin) {\n        await sendWhatsAppMessage(user.whatsapp_number, '‚ùå PINs do not match. Enter new PIN:');\n        await updateSession(session.id, {\n          session_data: {},\n          current_step: 'ask_new_pin',\n        });\n        return;\n      }\n\n      const hashedPin = hashPin(sessionData.newPin);\n      await updateUserPin(user.id, {\n        encrypted_pin: hashedPin,\n        failed_attempts: 0,\n        locked_until: null,\n      });\n\n      await sendWhatsAppMessage(user.whatsapp_number, '‚úÖ *PIN changed!*\\n\\nNew PIN is active.');\n      await deleteSession(session.id);\n    }\n  } catch (error) {\n    console.error('Error in recovery session:', error);\n    await sendWhatsAppMessage(user.whatsapp_number, '‚ùå Error.');\n    await deleteSession(session.id);\n  }\n}\n\nasync function handleSessionMessage(user: any, session: any, messageText: string) {\n  const sessionType = session.session_type;\n\n  if (sessionType === 'setup_pin') {\n    await handlePinSetupSession(user, session, messageText);\n  } else if (sessionType === 'send_crypto') {\n    await handleSendCryptoSession(user, session, messageText);\n  } else if (sessionType === 'mobile_money_deposit') {\n    await handleMobileMoneyDepositSession(user, session, messageText);\n  } else if (sessionType === 'mobile_money_withdraw') {\n    await handleMobileMoneyWithdrawSession(user, session, messageText);\n  } else if (sessionType === 'chama_create') {\n    await handleChamaCreateSession(user, session, messageText);\n  } else if (sessionType === 'chama_join') {\n    await handleChamaJoinSession(user, session, messageText);\n  } else if (sessionType === 'chama_contribute') {\n    await handleChamaContributeSession(user, session, messageText);\n  } else if (sessionType === 'loan_request') {\n    await handleLoanRequestSession(user, session, messageText);\n  } else if (sessionType === 'loan_pay') {\n    await handleLoanPaySession(user, session, messageText);\n  } else if (sessionType === 'recovery') {\n    await handleRecoverySession(user, session, messageText);\n  } else {\n    console.warn(`Unknown session: ${sessionType}`);\n    await deleteSession(session.id);\n  }\n}\n\n// ============================================================================\n// MAIN MESSAGE HANDLER\n// ============================================================================\nfunction parseIncomingMessage(webhookBody: any) {\n  try {\n    const entry = webhookBody.entry?.[0];\n    const change = entry?.changes?.[0];\n    const value = change?.value;\n    const message = value?.messages?.[0];\n    if (!message) return null;\n\n    return {\n      from: message.from,\n      id: message.id,\n      timestamp: message.timestamp,\n      type: message.type,\n      text: message.text?.body,\n      interactive: message.interactive,\n      button: message.interactive?.button_reply,\n      listReply: message.interactive?.list_reply,\n    };\n  } catch (error) {\n    console.error('Error parsing message:', error);\n    return null;\n  }\n}\n\nasync function handleIncomingMessage(from: string, messageData: any, messageId: string) {\n  try {\n    let user = await getUserByWhatsApp(from);\n\n    if (!user) {\n      await handleNewUser(from);\n      return;\n    }\n\n    await updateUser(user.id, { last_active: new Date().toISOString() });\n\n    const session = await getActiveSession(user.id);\n    let messageText = '';\n\n    if (messageData.type === 'text') {\n      messageText = messageData.text?.toLowerCase().trim() || '';\n    } else if (messageData.type === 'interactive') {\n      if (messageData.interactive?.type === 'button_reply') {\n        messageText = messageData.interactive.button_reply.id;\n      } else if (messageData.interactive?.type === 'list_reply') {\n        messageText = messageData.interactive.list_reply.id;\n      }\n    }\n\n    if (session) {\n      await handleSessionMessage(user, session, messageText);\n    } else {\n      await handleCommand(user, messageText);\n    }\n  } catch (error) {\n    console.error('Error handling message:', error);\n    await sendWhatsAppMessage(from, '‚ùå Error occurred. Try *menu*.');\n  }\n}\n\n// ============================================================================\n// WEBHOOK HANDLER\n// ============================================================================\nDeno.serve(async (req: Request) => {\n  if (req.method === 'OPTIONS') {\n    return new Response(null, { status: 200, headers: corsHeaders });\n  }\n\n  try {\n    const url = new URL(req.url);\n\n    if (req.method === 'GET') {\n      const mode = url.searchParams.get('hub.mode');\n      const token = url.searchParams.get('hub.verify_token');\n      const challenge = url.searchParams.get('hub.challenge');\n\n      if (mode === 'subscribe' && token === META_WEBHOOK_VERIFY_TOKEN) {\n        console.log('‚úÖ Webhook verified');\n        return new Response(challenge, { status: 200, headers: corsHeaders });\n      } else {\n        console.error('‚ùå Verification failed');\n        return new Response('Forbidden', { status: 403, headers: corsHeaders });\n      }\n    }\n\n    if (req.method === 'POST') {\n      const body = await req.json();\n      const message = parseIncomingMessage(body);\n\n      if (message) {\n        const displayText = message.text || message.button?.id || message.listReply?.id || '[interactive]';\n        console.log(`üì® ${message.from}: ${displayText}`);\n        handleIncomingMessage(message.from, message, message.id);\n      }\n\n      return new Response(JSON.stringify({ success: true }), {\n        status: 200,\n        headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n      });\n    }\n\n    return new Response(JSON.stringify({ error: 'Not found' }), {\n      status: 404,\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n    });\n  } catch (error) {\n    console.error('Error:', error);\n    return new Response(JSON.stringify({ error: 'Internal server error' }), {\n      status: 500,\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n    });\n  }\n});\n"},{"name":"blockchain.ts","content":"import { ethers } from 'npm:ethers@6.13.0';\n\n// Contract ABIs\nconst CHAMA_FACTORY_ABI = [\n  'function createChama(string memory name, string memory description, string memory inviteCode, uint256 sharePriceUSD, uint256 weeklyMinimum, uint256 loanInterestRate, uint256 lockupMonths) external returns (address chamaAddress)',\n  'function getChamaByInviteCode(string memory inviteCode) external view returns (address)',\n  'function getChamasByCreator(address creator) external view returns (address[] memory)',\n  'function getAllChamas() external view returns (address[] memory)',\n  'function getTotalChamas() external view returns (uint256)',\n  'function isInviteCodeAvailable(string memory inviteCode) external view returns (bool)',\n  'event ChamaCreated(address indexed chamaAddress, string inviteCode, address indexed creator, string name)',\n];\n\nconst CHAMA_ABI = [\n  'function name() external view returns (string memory)',\n  'function description() external view returns (string memory)',\n  'function inviteCode() external view returns (string memory)',\n  'function creator() external view returns (address)',\n  'function sharePriceUSD() external view returns (uint256)',\n  'function weeklyMinimumContribution() external view returns (uint256)',\n  'function loanInterestRate() external view returns (uint256)',\n  'function lockupPeriodMonths() external view returns (uint256)',\n  'function memberCount() external view returns (uint256)',\n  'function totalContributions() external view returns (uint256)',\n  'function totalETHHoldings() external view returns (uint256)',\n  'function totalTZSHoldings() external view returns (uint256)',\n  'function joinChama() external',\n  'function contribute(address token, uint256 amount, uint256 amountUSD) external payable',\n  'function requestLoan(address token, uint256 amount, uint256 durationDays) external returns (uint256)',\n  'function voteOnLoan(uint256 loanId, bool approve) external',\n  'function disburseLoan(uint256 loanId) external',\n  'function repayLoan(uint256 loanId, uint256 amount) external payable',\n  'function withdraw(address token, uint256 amount) external',\n  'function getMember(address memberAddress) external view returns (tuple(address wallet, uint256 totalContributions, uint256 ethShare, uint256 tzsShare, uint256 sharesOwned, uint256 joinedAt, uint256 lastContribution, uint256 missedContributions, bool isAdmin, bool isActive))',\n  'function getLoan(uint256 loanId) external view returns (tuple(address borrower, uint256 amount, address token, uint256 interestRate, uint256 totalDue, uint256 amountRepaid, uint256 requestedAt, uint256 disbursedAt, uint256 dueDate, uint256 approvalsCount, uint256 rejectionsCount, bool isApproved, bool isDisbursed, bool isActive, bool isRepaid))',\n  'function getChamaSummary() external view returns (uint256 _totalContributions, uint256 _totalETH, uint256 _totalTZS, uint256 _memberCount, bool _isActive)',\n  'function getAllMembers() external view returns (address[] memory)',\n  'function isMember(address user) external view returns (bool)',\n  'function getRequiredVotes() external view returns (uint256)',\n  'event MemberJoined(address indexed member, uint256 timestamp)',\n  'event ContributionMade(address indexed member, address indexed token, uint256 amount, uint256 shares)',\n  'event LoanRequested(uint256 indexed loanId, address indexed borrower, uint256 amount, address token, uint256 durationDays)',\n  'event LoanVoted(uint256 indexed loanId, address indexed voter, bool approved)',\n  'event LoanApproved(uint256 indexed loanId, uint256 approvalsCount)',\n  'event LoanDisbursed(uint256 indexed loanId, address indexed borrower, uint256 amount)',\n  'event LoanRepaid(uint256 indexed loanId, address indexed borrower, uint256 amount, bool fullyRepaid)',\n  'event WithdrawalMade(address indexed member, uint256 amount, address token)',\n];\n\nconst WALLET_MANAGER_ABI = [\n  'function depositETH(address user) external payable',\n  'function depositToken(address user, address token, uint256 amount) external',\n  'function withdrawETH(uint256 amount, address payable to) external',\n  'function withdrawToken(address token, uint256 amount, address to) external',\n  'function internalTransfer(address from, address to, address token, uint256 amount) external',\n  'function getBalance(address user, address token) external view returns (uint256)',\n  'function getETHBalance(address user) external view returns (uint256)',\n  'event Deposit(address indexed user, address indexed token, uint256 amount)',\n  'event Withdrawal(address indexed user, address indexed token, uint256 amount, address to)',\n  'event Transfer(address indexed from, address indexed to, address indexed token, uint256 amount)',\n];\n\n// Contract addresses\nconst CHAMA_FACTORY_ADDRESS = Deno.env.get('CHAMA_FACTORY_ADDRESS') || '0x305e088651c79CF4e459386e1908c690C0cAa88f';\nconst WALLET_MANAGER_ADDRESS = Deno.env.get('WALLET_MANAGER_ADDRESS') || '0x8bdF6F0C0938a2d8F61B0480d6d1a00331CCfdA8';\nconst TZS_TOKEN_ADDRESS = Deno.env.get('TZS_TOKEN_ADDRESS') || '0x0000000000000000000000000000000000000000';\nconst ETH_ADDRESS = '0x0000000000000000000000000000000000000000';\n\n// RPC and Explorer configuration\nconst RPC_URL = Deno.env.get('BLOCKCHAIN_RPC_URL') || 'https://remix-sepolia.g.alchemy.com/v2/demo';\nconst EXPLORER_BASE_URL = Deno.env.get('BLOCKCHAIN_EXPLORER_URL') || 'https://sepolia.etherscan.io';\n\n// Initialize provider\nlet provider: ethers.JsonRpcProvider;\nlet masterWallet: ethers.Wallet;\n\nexport function initializeBlockchain() {\n  provider = new ethers.JsonRpcProvider(RPC_URL);\n  const privateKey = Deno.env.get('MASTER_WALLET_PRIVATE_KEY');\n  if (!privateKey) {\n    throw new Error('MASTER_WALLET_PRIVATE_KEY not found in environment');\n  }\n  masterWallet = new ethers.Wallet(privateKey, provider);\n  console.log('Blockchain initialized with master wallet:', masterWallet.address);\n}\n\n// Helper: Generate explorer link\nexport function getExplorerLink(txHash: string): string {\n  return `${EXPLORER_BASE_URL}/tx/${txHash}`;\n}\n\nexport function getAddressExplorerLink(address: string): string {\n  return `${EXPLORER_BASE_URL}/address/${address}`;\n}\n\n// Helper: Get wallet from private key\nfunction getWalletFromPrivateKey(encryptedPrivateKey: string): ethers.Wallet {\n  // In production, decrypt the private key first\n  // For now, assume it's already decrypted or use master wallet\n  return masterWallet;\n}\n\n// ============================================================================\n// CHAMA FACTORY FUNCTIONS\n// ============================================================================\n\nexport interface CreateChamaParams {\n  name: string;\n  description: string;\n  inviteCode: string;\n  sharePriceUSD: number;\n  weeklyMinimum: number;\n  loanInterestRate: number;\n  lockupMonths: number;\n  creatorPrivateKey?: string;\n}\n\nexport interface CreateChamaResult {\n  success: boolean;\n  chamaAddress?: string;\n  txHash?: string;\n  explorerLink?: string;\n  error?: string;\n}\n\nexport async function createChamaOnChain(params: CreateChamaParams): Promise<CreateChamaResult> {\n  try {\n    const wallet = params.creatorPrivateKey\n      ? new ethers.Wallet(params.creatorPrivateKey, provider)\n      : masterWallet;\n\n    const factory = new ethers.Contract(CHAMA_FACTORY_ADDRESS, CHAMA_FACTORY_ABI, wallet);\n\n    // Convert USD values to 6 decimals (e.g., $10 = 10000000)\n    const sharePriceUSD = Math.floor(params.sharePriceUSD * 1e6);\n    const weeklyMinimum = Math.floor(params.weeklyMinimum * 1e6);\n\n    console.log('Creating Chama on-chain:', {\n      name: params.name,\n      inviteCode: params.inviteCode,\n      sharePriceUSD,\n      weeklyMinimum,\n      loanInterestRate: params.loanInterestRate,\n      lockupMonths: params.lockupMonths,\n    });\n\n    const tx = await factory.createChama(\n      params.name,\n      params.description,\n      params.inviteCode,\n      sharePriceUSD,\n      weeklyMinimum,\n      params.loanInterestRate,\n      params.lockupMonths\n    );\n\n    console.log('Transaction sent:', tx.hash);\n    const receipt = await tx.wait();\n    console.log('Transaction confirmed:', receipt.hash);\n\n    // Parse the ChamaCreated event to get the chama address\n    const event = receipt.logs\n      .map((log: any) => {\n        try {\n          return factory.interface.parseLog(log);\n        } catch {\n          return null;\n        }\n      })\n      .find((parsed: any) => parsed && parsed.name === 'ChamaCreated');\n\n    if (!event) {\n      throw new Error('ChamaCreated event not found');\n    }\n\n    const chamaAddress = event.args[0];\n\n    return {\n      success: true,\n      chamaAddress,\n      txHash: receipt.hash,\n      explorerLink: getExplorerLink(receipt.hash),\n    };\n  } catch (error: any) {\n    console.error('Error creating Chama on-chain:', error);\n    return {\n      success: false,\n      error: error.message || 'Unknown error',\n    };\n  }\n}\n\nexport async function getChamaByInviteCodeOnChain(inviteCode: string): Promise<string | null> {\n  try {\n    const factory = new ethers.Contract(CHAMA_FACTORY_ADDRESS, CHAMA_FACTORY_ABI, provider);\n    const address = await factory.getChamaByInviteCode(inviteCode);\n    return address === ethers.ZeroAddress ? null : address;\n  } catch (error) {\n    console.error('Error getting Chama by invite code:', error);\n    return null;\n  }\n}\n\n// ============================================================================\n// CHAMA CONTRACT FUNCTIONS\n// ============================================================================\n\nexport interface JoinChamaResult {\n  success: boolean;\n  txHash?: string;\n  explorerLink?: string;\n  error?: string;\n}\n\nexport async function joinChamaOnChain(\n  chamaAddress: string,\n  userPrivateKey?: string\n): Promise<JoinChamaResult> {\n  try {\n    const wallet = userPrivateKey\n      ? new ethers.Wallet(userPrivateKey, provider)\n      : masterWallet;\n\n    const chama = new ethers.Contract(chamaAddress, CHAMA_ABI, wallet);\n\n    console.log('Joining Chama on-chain:', chamaAddress);\n\n    const tx = await chama.joinChama();\n    console.log('Transaction sent:', tx.hash);\n\n    const receipt = await tx.wait();\n    console.log('Transaction confirmed:', receipt.hash);\n\n    return {\n      success: true,\n      txHash: receipt.hash,\n      explorerLink: getExplorerLink(receipt.hash),\n    };\n  } catch (error: any) {\n    console.error('Error joining Chama on-chain:', error);\n    return {\n      success: false,\n      error: error.message || 'Unknown error',\n    };\n  }\n}\n\nexport interface ContributeToChamaParams {\n  chamaAddress: string;\n  token: 'ETH' | 'TZS';\n  amount: string; // Amount in ETH or TZS\n  amountUSD: number; // USD value with 6 decimals\n  userPrivateKey?: string;\n  tzsTokenAddress?: string;\n}\n\nexport interface ContributeToChamaResult {\n  success: boolean;\n  txHash?: string;\n  explorerLink?: string;\n  shares?: string;\n  error?: string;\n}\n\nexport async function contributeToChamaOnChain(\n  params: ContributeToChamaParams\n): Promise<ContributeToChamaResult> {\n  try {\n    const wallet = params.userPrivateKey\n      ? new ethers.Wallet(params.userPrivateKey, provider)\n      : masterWallet;\n\n    const chama = new ethers.Contract(params.chamaAddress, CHAMA_ABI, wallet);\n\n    const tokenAddress = params.token === 'ETH' ? ETH_ADDRESS : (params.tzsTokenAddress || TZS_TOKEN_ADDRESS);\n    const amountWei = ethers.parseEther(params.amount);\n    const amountUSD = Math.floor(params.amountUSD * 1e6);\n\n    console.log('Contributing to Chama on-chain:', {\n      chamaAddress: params.chamaAddress,\n      token: params.token,\n      amount: params.amount,\n      amountUSD: params.amountUSD,\n    });\n\n    let tx;\n    if (params.token === 'ETH') {\n      tx = await chama.contribute(tokenAddress, amountWei, amountUSD, {\n        value: amountWei,\n      });\n    } else {\n      // For TZS, need to approve first (handled separately)\n      tx = await chama.contribute(tokenAddress, amountWei, amountUSD);\n    }\n\n    console.log('Transaction sent:', tx.hash);\n    const receipt = await tx.wait();\n    console.log('Transaction confirmed:', receipt.hash);\n\n    return {\n      success: true,\n      txHash: receipt.hash,\n      explorerLink: getExplorerLink(receipt.hash),\n    };\n  } catch (error: any) {\n    console.error('Error contributing to Chama on-chain:', error);\n    return {\n      success: false,\n      error: error.message || 'Unknown error',\n    };\n  }\n}\n\nexport interface RequestLoanParams {\n  chamaAddress: string;\n  token: 'ETH' | 'TZS';\n  amount: string;\n  durationDays: number;\n  userPrivateKey?: string;\n  tzsTokenAddress?: string;\n}\n\nexport interface RequestLoanResult {\n  success: boolean;\n  loanId?: number;\n  txHash?: string;\n  explorerLink?: string;\n  error?: string;\n}\n\nexport async function requestLoanOnChain(params: RequestLoanParams): Promise<RequestLoanResult> {\n  try {\n    const wallet = params.userPrivateKey\n      ? new ethers.Wallet(params.userPrivateKey, provider)\n      : masterWallet;\n\n    const chama = new ethers.Contract(params.chamaAddress, CHAMA_ABI, wallet);\n\n    const tokenAddress = params.token === 'ETH' ? ETH_ADDRESS : (params.tzsTokenAddress || TZS_TOKEN_ADDRESS);\n    const amountWei = ethers.parseEther(params.amount);\n\n    console.log('Requesting loan on-chain:', {\n      chamaAddress: params.chamaAddress,\n      token: params.token,\n      amount: params.amount,\n      durationDays: params.durationDays,\n    });\n\n    const tx = await chama.requestLoan(tokenAddress, amountWei, params.durationDays);\n    console.log('Transaction sent:', tx.hash);\n\n    const receipt = await tx.wait();\n    console.log('Transaction confirmed:', receipt.hash);\n\n    // Parse the LoanRequested event to get the loan ID\n    const event = receipt.logs\n      .map((log: any) => {\n        try {\n          return chama.interface.parseLog(log);\n        } catch {\n          return null;\n        }\n      })\n      .find((parsed: any) => parsed && parsed.name === 'LoanRequested');\n\n    const loanId = event ? Number(event.args[0]) : undefined;\n\n    return {\n      success: true,\n      loanId,\n      txHash: receipt.hash,\n      explorerLink: getExplorerLink(receipt.hash),\n    };\n  } catch (error: any) {\n    console.error('Error requesting loan on-chain:', error);\n    return {\n      success: false,\n      error: error.message || 'Unknown error',\n    };\n  }\n}\n\nexport interface VoteLoanResult {\n  success: boolean;\n  txHash?: string;\n  explorerLink?: string;\n  error?: string;\n}\n\nexport async function voteOnLoanOnChain(\n  chamaAddress: string,\n  loanId: number,\n  approve: boolean,\n  userPrivateKey?: string\n): Promise<VoteLoanResult> {\n  try {\n    const wallet = userPrivateKey\n      ? new ethers.Wallet(userPrivateKey, provider)\n      : masterWallet;\n\n    const chama = new ethers.Contract(chamaAddress, CHAMA_ABI, wallet);\n\n    console.log('Voting on loan on-chain:', { chamaAddress, loanId, approve });\n\n    const tx = await chama.voteOnLoan(loanId, approve);\n    console.log('Transaction sent:', tx.hash);\n\n    const receipt = await tx.wait();\n    console.log('Transaction confirmed:', receipt.hash);\n\n    return {\n      success: true,\n      txHash: receipt.hash,\n      explorerLink: getExplorerLink(receipt.hash),\n    };\n  } catch (error: any) {\n    console.error('Error voting on loan on-chain:', error);\n    return {\n      success: false,\n      error: error.message || 'Unknown error',\n    };\n  }\n}\n\n// ============================================================================\n// VIEW FUNCTIONS\n// ============================================================================\n\nexport async function getChamaSummaryOnChain(chamaAddress: string) {\n  try {\n    const chama = new ethers.Contract(chamaAddress, CHAMA_ABI, provider);\n    const summary = await chama.getChamaSummary();\n    return {\n      totalContributions: Number(summary[0]) / 1e6, // Convert from 6 decimals\n      totalETH: ethers.formatEther(summary[1]),\n      totalTZS: ethers.formatEther(summary[2]),\n      memberCount: Number(summary[3]),\n      isActive: summary[4],\n    };\n  } catch (error) {\n    console.error('Error getting Chama summary:', error);\n    return null;\n  }\n}\n\nexport async function isMemberOnChain(chamaAddress: string, userAddress: string): Promise<boolean> {\n  try {\n    const chama = new ethers.Contract(chamaAddress, CHAMA_ABI, provider);\n    return await chama.isMember(userAddress);\n  } catch (error) {\n    console.error('Error checking membership:', error);\n    return false;\n  }\n}\n\nexport async function getMemberDetailsOnChain(chamaAddress: string, userAddress: string) {\n  try {\n    const chama = new ethers.Contract(chamaAddress, CHAMA_ABI, provider);\n    const member = await chama.getMember(userAddress);\n    return {\n      wallet: member[0],\n      totalContributions: Number(member[1]) / 1e6,\n      ethShare: ethers.formatEther(member[2]),\n      tzsShare: ethers.formatEther(member[3]),\n      sharesOwned: ethers.formatEther(member[4]),\n      joinedAt: new Date(Number(member[5]) * 1000),\n      lastContribution: Number(member[6]) > 0 ? new Date(Number(member[6]) * 1000) : null,\n      missedContributions: Number(member[7]),\n      isAdmin: member[8],\n      isActive: member[9],\n    };\n  } catch (error) {\n    console.error('Error getting member details:', error);\n    return null;\n  }\n}\n\nexport async function getLoanDetailsOnChain(chamaAddress: string, loanId: number) {\n  try {\n    const chama = new ethers.Contract(chamaAddress, CHAMA_ABI, provider);\n    const loan = await chama.getLoan(loanId);\n    return {\n      borrower: loan[0],\n      amount: ethers.formatEther(loan[1]),\n      token: loan[2],\n      interestRate: Number(loan[3]),\n      totalDue: ethers.formatEther(loan[4]),\n      amountRepaid: ethers.formatEther(loan[5]),\n      requestedAt: new Date(Number(loan[6]) * 1000),\n      disbursedAt: Number(loan[7]) > 0 ? new Date(Number(loan[7]) * 1000) : null,\n      dueDate: new Date(Number(loan[8]) * 1000),\n      approvalsCount: Number(loan[9]),\n      rejectionsCount: Number(loan[10]),\n      isApproved: loan[11],\n      isDisbursed: loan[12],\n      isActive: loan[13],\n      isRepaid: loan[14],\n    };\n  } catch (error) {\n    console.error('Error getting loan details:', error);\n    return null;\n  }\n}\n\n// Initialize on module load\ntry {\n  initializeBlockchain();\n} catch (error) {\n  console.error('Failed to initialize blockchain:', error);\n}\n"}]}
